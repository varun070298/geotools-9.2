/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. /home/luis/Downloads/geotools-9.2_terra/modules/library/cql/target/generated-sources/jjtree-javacc/org/geotools/filter/text/generated/parsers/ECQLGrammar.jj */
/*@egen*//*
 *    GeoTools - The Open Source Java GIS Tookit
 *    http://geotools.orgLITERAL
 *
 *    (C) 2002-2008, Open Source Geospatial Foundation (OSGeo)
 
 *
 *    This library is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU Lesser General Public
 *    License as published by the Free Software Foundation;
 *    version 2.1 of the License.
 *
 *    This library is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *    Lesser General Public License for more details.
 */
 
options {
   STATIC=false;                                                                                                                                                                                                                                                                   
 
   SANITY_CHECK=true;                   
   
   FORCE_LA_CHECK=false; // force lookahead ambiguity checking in such instances. This option don't take into account the locak lookagead

   UNICODE_INPUT = true;
   JAVA_UNICODE_ESCAPE = true;

   	// debug
   DEBUG_TOKEN_MANAGER=false;
   DEBUG_PARSER=false;
}

PARSER_BEGIN(ECQLParser)

package org.geotools.filter.text.generated.parsers;
        
import java.util.HashSet;
import java.util.Set;
import java.util.logging.Logger;



/**
 * ECQLParser is the result of a javacc jjtree grammar.
 * 
 * @author  Mauricio Pazos - Axios Engineering
 * @since 2.6
 */
public class ECQLParser/*@bgen(jjtree)*/implements ECQLParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTECQLParserState jjtree = new JJTECQLParserState();

/*@egen*/
  private static final Logger LOGGER = Logger.getLogger(CQLParser.class.getName());
  
  public void jjtreeOpenNodeScope(Node n) throws ParseException {
 
  }

  public void jjtreeCloseNodeScope(Node n) throws ParseException {

  }

  // initialize geooperations
  protected static final Set GEOOP = new HashSet();
  static {
		GEOOP.add("EQUALS");
		GEOOP.add("DISJOINT");
		GEOOP.add("INTERSECTS");
		GEOOP.add("TOUCHES");
		GEOOP.add("CROSSES");
		GEOOP.add("WITHIN");
		GEOOP.add("CONTAINS");
		GEOOP.add("OVERLAPS");
		GEOOP.add("RELATE");
		GEOOP.add("BBOX");
  }
  protected boolean isGeoOp() {
  
        return "(".equals(getToken(2).image)
            && GEOOP.contains(getToken(1).image.toUpperCase());
  }
  
  protected static final Set RELGEOOP = new HashSet();
  static {
  	RELGEOOP.add("DWITHIN");
  	RELGEOOP.add("BEYOND"); 
  	
  }
  protected boolean isRelGeoOp() {
  
        return "(".equals(getToken(2).image)
            && RELGEOOP.contains(getToken(1).image.toUpperCase());
  }
  
}

PARSER_END(ECQLParser)


SKIP : /* WHITE SPACE */
{
  		" "
	| 	"\t"
	| 	"\n"
	| 	"\r"
	| 	"\f"
}


/*
 * <character string literal>
 */
TOKEN:
{
	  < STRING_LITERAL: "'" ( "''" | ~["'"] )* "'" > : DEFAULT
}

TOKEN [IGNORE_CASE]:
{
    < #DIMENSION_SYMBOL: "*"| "T" | "F" | "0" | "1" | "2"> |
    < DE9IM_PATTERN: <DIMENSION_SYMBOL><DIMENSION_SYMBOL><DIMENSION_SYMBOL><DIMENSION_SYMBOL><DIMENSION_SYMBOL><DIMENSION_SYMBOL><DIMENSION_SYMBOL><DIMENSION_SYMBOL><DIMENSION_SYMBOL> >
}


/*
 * keywords
 */
TOKEN [IGNORE_CASE]:  /* keywords */
{
   < AND: "and"> |
   < OR: "or"> |
   < NOT: "not"> |
   < EQ:  "="> |
   < NEQ: "<>" > |
   < GT:  ">" > |
   < LT: "<" > |
   < GTE:">="> |
   < LTE:"<="> |
   < TRUE: "true"> |
   < FALSE: "false"> |
   < UNKNOWN: "unknown"> |
   < LIKE: "like" > |
   < ILIKE: "ilike" > |
   < BETWEEN: "between"> |
   < ID: "id" > |
   < IN: "in" > |
   < IS: "is" > |
   < NULL: "null" >
}

TOKEN [IGNORE_CASE]: /* include all and exclude all filters */
{
  < INCLUDE: "include"> |
  < EXCLUDE: "exclude">
}
  
TOKEN [IGNORE_CASE]: /* geometry markers */
{
  < POINT: "point"> |
  < LINESTRING: "linestring"> |
  < POLYGON: "polygon"> |
  < MULTIPOINT: "multipoint"> |
  < MULTILINESTRING: "multilinestring"> |
  < MULTIPOLYGON: "multipolygon"> |
  < GEOMETRYCOLLECTION: "geometrycollection"> |
  < ENVELOPE: "envelope">
}

TOKEN [IGNORE_CASE]: /* temporal expression*/
{
	<TEQUALS: "tequals">  | 
	<BEFORE: "before"> 	| 
	<DURING: "during"> 	|
	<AFTER:  "after">  	|
	<UTC: "T">
}
TOKEN [IGNORE_CASE]: /* existence predicate*/
{
	<EXISTS: "exists"> |
	<DOES_NOT_EXIST: "does-not-exist">
}

TOKEN [IGNORE_CASE]:  
{
  < EQUALS: "equals"> |
  < DISJOINT: "disjoint"> |
  < INTERSECTS: "intersects"> |
  < TOUCHES: "touches"> |
  < CROSSES: "crosses"> |
  < WITHIN: "within"> |
  < CONTAINS: "contains"> |
  < OVERLAPS: "overlaps"> |
  < RELATE: "relate"> |
  < BBOX: "bbox"> 
}

TOKEN [IGNORE_CASE]: /* relgeoop name */
{
  < DWITHIN: "dwithin"> |
  < BEYOND: "beyond"> 
}

TOKEN [IGNORE_CASE]:
{
	<FEET: "feet" > | 
	<METERS: "meters"> | 
	<STATUTE_MILES: "statute miles"> | 
	<NAUTICAL_MILES: "nautical miles"> | 
	<KILOMETERS: "kilometers">
}


TOKEN:
{
  < LP: "("> |
  < RP: ")"> |
  < LSP: "["> |
  < RSP: "]"> |
  < COMMA: ","> |
  < SENTENCE_SEPARATOR: ";"> |
  < PERIOD: "."> |
  < SLASH: "/"> |
  < COLON: ":">	|
  < MULT: "*"> |
  < PLUS: "+"> |
  < MINUS: "-" > | 
  < DOUBLE_QUOTE: "\"">
}


// Note, because float and int can technically have the same grammar,
// put int first to make token manager have preference for it...
// The same case occurs between identifier and duration tokens, 
// then DURATION has preference over IDENTIFIER
TOKEN [IGNORE_CASE]: /* Literals */
{

  	< INTEGER_LITERAL: (<DIGIT>)+ > |
  	< FLOATING_LITERAL:
    	( ( <DIGIT> )* "." ( <DIGIT> )+ (<EXPONENT>)? ) |
    	( ( <DIGIT> )+ ("." ( <DIGIT> )*)? (<EXPONENT>)? )
  	> |

	< #DUR_DAY:	  (<DIGIT>)+ "D" > |
	< #DUR_MONTH: (<DIGIT>)+ "M" (<DUR_DAY>)? > |
	< #DUR_YEAR:  (<DIGIT>)+ "Y" (<DUR_MONTH>)? > |	
	< #DUR_DATE:  (<DUR_DAY> | <DUR_MONTH> | <DUR_YEAR>) ("T" <DUR_TIME>)?> | 

	< #DUR_HOUR:  (<DIGIT>)+ "H" (<DUR_MINUTE>)?> |
	< #DUR_MINUTE:(<DIGIT>)+ "M" (<DUR_SECOND>)? > |
	< #DUR_SECOND:(<DIGIT>)+ "S" > |	
	< #DUR_TIME:  (<DUR_HOUR> | <DUR_MINUTE> | <DUR_SECOND>) > | 
	
	< DURATION:  ("P" <DUR_DATE> |  "T" <DUR_TIME>) > |
	
	< #FULL_DATE: <DIGIT><DIGIT><DIGIT><DIGIT> "-" <DIGIT><DIGIT> "-" <DIGIT><DIGIT> > |
    < #TIME_ZONE: ("Z") | (("+"|"-") <DIGIT><DIGIT> (":")? <DIGIT><DIGIT>) > | 
    < #UTC_TIME: <DIGIT><DIGIT> ":" <DIGIT><DIGIT> ":" <DIGIT><DIGIT> ("." (<DIGIT>)+)? (<TIME_ZONE>)? > |
	< DATE : <FULL_DATE>(<TIME_ZONE>)? > |
	< DATE_TIME : <FULL_DATE>"T"<UTC_TIME> > |

    < IDENTIFIER: (<LETTER> (<LETTER>|<DIGIT>)*) | <DOUBLE_QUOTE> (<ANY>)+ <DOUBLE_QUOTE> > |

	< #ANY: ~[" "] > |
  	< #LETTER: [ "a"-"z", "A"-"Z" , "_"] > |
  	< #DIGIT: [ "0"-"9"] > |
  	< #EXPONENT: ["e","E"] (["+","-"])? (<DIGIT>)+ > 
}



/*
 * Program structuring syntax to parse a single filter.
 */
Node FilterCompilationUnit() :
{}
{
   SearchCondition()
   <EOF>
   {return jjtree.rootNode();}
}

/*
 * Program structuring syntax to parse a single expression.
 */
Node ExpressionCompilationUnit() :
{}
{
    ECQLExpression()
   <EOF>
   {return jjtree.rootNode();}
}

void ECQLExpression()     :
{}
{
    	Expression()
}

/*
 * Program structuring syntax to parse a list of filters.
 */
Node FilterListCompilationUnit() :
{}
{
   SequenceOfSearchConditions()
   <EOF>
   {return jjtree.rootNode();}
}


/*
 * <SequenceOfSearchConditions> ::= 
 * 			<search condition>
 * 		|	<SequenceOfSearchConditions> ; <search condition>
 */ 
void SequenceOfSearchConditions()      :
{}
{
		SearchCondition() (<SENTENCE_SEPARATOR> SearchCondition())*
}

void SearchCondition()      :
{}
{
	 BooleanValueExpression()
}

/*
 * <boolean value expression> ::= 
 *			<boolean term>
 * 		| 	<boolean value expression> OR <boolean term>
 */
void BooleanValueExpression()      :
{}
{
		BooleanTerm()( <OR>/*@bgen(jjtree) Boolean_Or_Node */
                                    {
                                      SimpleNode jjtn001 = new SimpleNode(JJTBOOLEAN_OR_NODE);
                                      boolean jjtc001 = true;
                                      jjtree.openNodeScope(jjtn001);
                                      jjtreeOpenNodeScope(jjtn001);
                                    }
                                    try {
/*@egen*/ BooleanTerm()/*@bgen(jjtree)*/
                                    } catch (Throwable jjte001) {
                                      if (jjtc001) {
                                        jjtree.clearNodeScope(jjtn001);
                                        jjtc001 = false;
                                      } else {
                                        jjtree.popNode();
                                      }
                                      if (jjte001 instanceof RuntimeException) {
                                        throw (RuntimeException)jjte001;
                                      }
                                      if (jjte001 instanceof ParseException) {
                                        throw (ParseException)jjte001;
                                      }
                                      throw (Error)jjte001;
                                    } finally {
                                      if (jjtc001) {
                                        jjtree.closeNodeScope(jjtn001, true);
                                        jjtreeCloseNodeScope(jjtn001);
                                      }
                                    }
/*@egen*/ )*
}

/*
 * <boolean term> ::= 
 *            <boolean factor>
 *          | <boolean term> AND <boolean factor>
 */
void BooleanTerm()       :
{}
{
	 BooleanFactor()( <AND>/*@bgen(jjtree) Boolean_And_Node */
                                {
                                  SimpleNode jjtn001 = new SimpleNode(JJTBOOLEAN_AND_NODE);
                                  boolean jjtc001 = true;
                                  jjtree.openNodeScope(jjtn001);
                                  jjtreeOpenNodeScope(jjtn001);
                                }
                                try {
/*@egen*/ BooleanFactor()/*@bgen(jjtree)*/
                                } catch (Throwable jjte001) {
                                  if (jjtc001) {
                                    jjtree.clearNodeScope(jjtn001);
                                    jjtc001 = false;
                                  } else {
                                    jjtree.popNode();
                                  }
                                  if (jjte001 instanceof RuntimeException) {
                                    throw (RuntimeException)jjte001;
                                  }
                                  if (jjte001 instanceof ParseException) {
                                    throw (ParseException)jjte001;
                                  }
                                  throw (Error)jjte001;
                                } finally {
                                  if (jjtc001) {
                                    jjtree.closeNodeScope(jjtn001, true);
                                    jjtreeCloseNodeScope(jjtn001);
                                  }
                                }
/*@egen*/ )*
}


void BooleanFactor()      :
{}
{
	  <NOT>/*@bgen(jjtree) Boolean_Not_Node */
                {
                  SimpleNode jjtn001 = new SimpleNode(JJTBOOLEAN_NOT_NODE);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                  jjtreeOpenNodeScope(jjtn001);
                }
                try {
/*@egen*/ BooleanPrimary()/*@bgen(jjtree)*/
                } catch (Throwable jjte001) {
                  if (jjtc001) {
                    jjtree.clearNodeScope(jjtn001);
                    jjtc001 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte001 instanceof RuntimeException) {
                    throw (RuntimeException)jjte001;
                  }
                  if (jjte001 instanceof ParseException) {
                    throw (ParseException)jjte001;
                  }
                  throw (Error)jjte001;
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001, true);
                    jjtreeCloseNodeScope(jjtn001);
                  }
                }
/*@egen*/
	| BooleanPrimary()

}

void BooleanPrimary()      :
{}
{
	   LOOKAHEAD(Predicate()) Predicate() 
	|  IncludeExcludePredicate()
	|  <LP>SearchCondition()<RP> 
	|  <LSP>SearchCondition()<RSP> 
	|  RoutineInvocation() 
}

/*
 * <predicate> ::= <comparison predicate>
 * 	| <text predicate>
 * 	| <null predicate>
 * 	| <temporal predicate>
 * 	| <classification predicate> (*not supported*)
 * 	| <existence predicate> 
 * 	| <between predicate> (*extension*)
 *  | <includeexclude predicate> (*extesion*)
 *  | <id predicate>
 */
void Predicate()      :
{}
{
        IdPredicateDeprecated() // TODO deprecated syntax
    |   IdPredicate()
    |   LOOKAHEAD(InPredicate()) InPredicate()
    |   LOOKAHEAD(TemporalPredicate()) TemporalPredicate() 
    |   Expression()  
        (
                LOOKAHEAD(2) likePredicate()
            |   LOOKAHEAD(2) IlikePredicate()
            |   LOOKAHEAD(2) ExistencePredicate() 
            |   LOOKAHEAD(2) NullPredicate() 
            |   LOOKAHEAD(2) BetweenPredicate()     
            |   ComparisonPredicate() 
        )
        
}

/* ---------------------------------------- *
 *   	<id predicate>
 * ---------------------------------------- *
/*
 * Deprecated Syntax
 * <id predicate> ::= "ID" "IN" <id list> 
 * <id list> ::= <id value>, {"," id value}
 */
void IdPredicateDeprecated()                   :
{/*@bgen(jjtree) Id_Predicate_Node */
  SimpleNode jjtn000 = new SimpleNode(JJTID_PREDICATE_NODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Id_Predicate_Node */
    try {
/*@egen*/
    <ID> <IN> IdList()/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
    }
/*@egen*/      
    {
        
        LOGGER.warning("ID IN (...) is a deprecated syntax, you should use IN (...)");
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

/* New syntax
 * <id predicate> ::= "IN" <id list> 
 * <id list> ::= <id value>, {"," id value}
 */
void IdPredicate()                   :
{/*@bgen(jjtree) Id_Predicate_Node */
  SimpleNode jjtn000 = new SimpleNode(JJTID_PREDICATE_NODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Id_Predicate_Node */
    try {
/*@egen*/
    <IN> IdList()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/   
}

void IdList()      :
{}
{
	<LP> IdValue()( <COMMA>  IdValue() )* <RP> 
	
} 

void IdValue()                 :
{/*@bgen(jjtree) FEATURE_ID_NODE */
  SimpleNode jjtn000 = new SimpleNode(JJTFEATURE_ID_NODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FEATURE_ID_NODE */
      try {
/*@egen*/
      <STRING_LITERAL>
    | <INTEGER_LITERAL>/*@bgen(jjtree)*/
      } finally {
        if (jjtc000) {
          jjtree.closeNodeScope(jjtn000, true);
          jjtreeCloseNodeScope(jjtn000);
        }
      }
/*@egen*/ 
}

/* ---------------------------------------- *
 *   	<in predicate>
 * ---------------------------------------- *
/*
/* <in predicate>    	::=   <attribute-name> [  "NOT"  ]  "IN"  <in predicate value>
 * <in predicate value>    ::=   "(" <in value list> ")"
 * <in value list>         ::=   <expression> {"," <expression>} 
 */
void InPredicate()      :
{}
{
        LOOKAHEAD(3)    Attribute() <NOT> <IN>/*@bgen(jjtree) Not_In_Predicate_Node */
                                               {
                                                 SimpleNode jjtn001 = new SimpleNode(JJTNOT_IN_PREDICATE_NODE);
                                                 boolean jjtc001 = true;
                                                 jjtree.openNodeScope(jjtn001);
                                                 jjtreeOpenNodeScope(jjtn001);
                                               }
                                               try {
/*@egen*/ InPredicateList()/*@bgen(jjtree)*/
                                               } catch (Throwable jjte001) {
                                                 if (jjtc001) {
                                                   jjtree.clearNodeScope(jjtn001);
                                                   jjtc001 = false;
                                                 } else {
                                                   jjtree.popNode();
                                                 }
                                                 if (jjte001 instanceof RuntimeException) {
                                                   throw (RuntimeException)jjte001;
                                                 }
                                                 if (jjte001 instanceof ParseException) {
                                                   throw (ParseException)jjte001;
                                                 }
                                                 throw (Error)jjte001;
                                               } finally {
                                                 if (jjtc001) {
                                                   jjtree.closeNodeScope(jjtn001, true);
                                                   jjtreeCloseNodeScope(jjtn001);
                                                 }
                                               }
/*@egen*/
    |                   Attribute()       <IN>/*@bgen(jjtree) In_Predicate_Node */
                                               {
                                                 SimpleNode jjtn002 = new SimpleNode(JJTIN_PREDICATE_NODE);
                                                 boolean jjtc002 = true;
                                                 jjtree.openNodeScope(jjtn002);
                                                 jjtreeOpenNodeScope(jjtn002);
                                               }
                                               try {
/*@egen*/ InPredicateList()/*@bgen(jjtree)*/
                                               } catch (Throwable jjte002) {
                                                 if (jjtc002) {
                                                   jjtree.clearNodeScope(jjtn002);
                                                   jjtc002 = false;
                                                 } else {
                                                   jjtree.popNode();
                                                 }
                                                 if (jjte002 instanceof RuntimeException) {
                                                   throw (RuntimeException)jjte002;
                                                 }
                                                 if (jjte002 instanceof ParseException) {
                                                   throw (ParseException)jjte002;
                                                 }
                                                 throw (Error)jjte002;
                                               } finally {
                                                 if (jjtc002) {
                                                   jjtree.closeNodeScope(jjtn002, true);
                                                   jjtreeCloseNodeScope(jjtn002);
                                                 }
                                               }
/*@egen*/ 
}


void InPredicateList()      :
{}
{
	<LP> ExpressionInList()( <COMMA>  ExpressionInList() )* <RP>	
} 

void ExpressionInList()                         :
{/*@bgen(jjtree) Expression_In_List_Node */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSION_IN_LIST_NODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Expression_In_List_Node */
        try {
/*@egen*/
	Expression()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/
}


/* ---------------------------------------- *
 *   	<routine invocation>
 * ---------------------------------------- *
/*
 * <routine invocation> ::= 
 *	 <geoop name><georoutine argument list>
 * | <relgeoop name><relgeoop argument list>
 * | <routine name><argument list>
 */
void RoutineInvocation()      :
{}
{
		LOOKAHEAD({ isGeoOp() })   		RoutineInvocationGeoOp()
	|	LOOKAHEAD({ isRelGeoOp() })		RoutineInvocationRelGeoOp()
	|	RoutineInvocationGeneric()
}

void RoutineInvocationGeoOp()      :
{}
{
  	<EQUALS>/*@bgen(jjtree) RoutineInvocation_GeoOp_Equal_Node */
                        {
                          SimpleNode jjtn001 = new SimpleNode(JJTROUTINEINVOCATION_GEOOP_EQUAL_NODE);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                          jjtreeOpenNodeScope(jjtn001);
                        }
                        try {
/*@egen*/ 	GeoRoutineArgumentList()/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001, true);
                            jjtreeCloseNodeScope(jjtn001);
                          }
                        }
/*@egen*/
  |	<DISJOINT>/*@bgen(jjtree) RoutineInvocation_GeoOp_Disjoint_Node */
                        {
                          SimpleNode jjtn002 = new SimpleNode(JJTROUTINEINVOCATION_GEOOP_DISJOINT_NODE);
                          boolean jjtc002 = true;
                          jjtree.openNodeScope(jjtn002);
                          jjtreeOpenNodeScope(jjtn002);
                        }
                        try {
/*@egen*/ 	GeoRoutineArgumentList()/*@bgen(jjtree)*/
                        } catch (Throwable jjte002) {
                          if (jjtc002) {
                            jjtree.clearNodeScope(jjtn002);
                            jjtc002 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte002 instanceof RuntimeException) {
                            throw (RuntimeException)jjte002;
                          }
                          if (jjte002 instanceof ParseException) {
                            throw (ParseException)jjte002;
                          }
                          throw (Error)jjte002;
                        } finally {
                          if (jjtc002) {
                            jjtree.closeNodeScope(jjtn002, true);
                            jjtreeCloseNodeScope(jjtn002);
                          }
                        }
/*@egen*/
  |	<INTERSECTS>/*@bgen(jjtree) RoutineInvocation_GeoOp_Intersect_Node */
                     {
                       SimpleNode jjtn003 = new SimpleNode(JJTROUTINEINVOCATION_GEOOP_INTERSECT_NODE);
                       boolean jjtc003 = true;
                       jjtree.openNodeScope(jjtn003);
                       jjtreeOpenNodeScope(jjtn003);
                     }
                     try {
/*@egen*/ GeoRoutineArgumentList()/*@bgen(jjtree)*/
                     } catch (Throwable jjte003) {
                       if (jjtc003) {
                         jjtree.clearNodeScope(jjtn003);
                         jjtc003 = false;
                       } else {
                         jjtree.popNode();
                       }
                       if (jjte003 instanceof RuntimeException) {
                         throw (RuntimeException)jjte003;
                       }
                       if (jjte003 instanceof ParseException) {
                         throw (ParseException)jjte003;
                       }
                       throw (Error)jjte003;
                     } finally {
                       if (jjtc003) {
                         jjtree.closeNodeScope(jjtn003, true);
                         jjtreeCloseNodeScope(jjtn003);
                       }
                     }
/*@egen*/
  |	<TOUCHES>/*@bgen(jjtree) RoutineInvocation_GeoOp_Touch_Node */
                        {
                          SimpleNode jjtn004 = new SimpleNode(JJTROUTINEINVOCATION_GEOOP_TOUCH_NODE);
                          boolean jjtc004 = true;
                          jjtree.openNodeScope(jjtn004);
                          jjtreeOpenNodeScope(jjtn004);
                        }
                        try {
/*@egen*/ 	GeoRoutineArgumentList()/*@bgen(jjtree)*/
                        } catch (Throwable jjte004) {
                          if (jjtc004) {
                            jjtree.clearNodeScope(jjtn004);
                            jjtc004 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte004 instanceof RuntimeException) {
                            throw (RuntimeException)jjte004;
                          }
                          if (jjte004 instanceof ParseException) {
                            throw (ParseException)jjte004;
                          }
                          throw (Error)jjte004;
                        } finally {
                          if (jjtc004) {
                            jjtree.closeNodeScope(jjtn004, true);
                            jjtreeCloseNodeScope(jjtn004);
                          }
                        }
/*@egen*/
  |	<CROSSES>/*@bgen(jjtree) RoutineInvocation_GeoOp_Cross_Node */
                        {
                          SimpleNode jjtn005 = new SimpleNode(JJTROUTINEINVOCATION_GEOOP_CROSS_NODE);
                          boolean jjtc005 = true;
                          jjtree.openNodeScope(jjtn005);
                          jjtreeOpenNodeScope(jjtn005);
                        }
                        try {
/*@egen*/ 	GeoRoutineArgumentList()/*@bgen(jjtree)*/
                        } catch (Throwable jjte005) {
                          if (jjtc005) {
                            jjtree.clearNodeScope(jjtn005);
                            jjtc005 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte005 instanceof RuntimeException) {
                            throw (RuntimeException)jjte005;
                          }
                          if (jjte005 instanceof ParseException) {
                            throw (ParseException)jjte005;
                          }
                          throw (Error)jjte005;
                        } finally {
                          if (jjtc005) {
                            jjtree.closeNodeScope(jjtn005, true);
                            jjtreeCloseNodeScope(jjtn005);
                          }
                        }
/*@egen*/
  |	<WITHIN>/*@bgen(jjtree) RoutineInvocation_GeoOp_Within_Node */
                        {
                          SimpleNode jjtn006 = new SimpleNode(JJTROUTINEINVOCATION_GEOOP_WITHIN_NODE);
                          boolean jjtc006 = true;
                          jjtree.openNodeScope(jjtn006);
                          jjtreeOpenNodeScope(jjtn006);
                        }
                        try {
/*@egen*/ 	GeoRoutineArgumentList()/*@bgen(jjtree)*/
                        } catch (Throwable jjte006) {
                          if (jjtc006) {
                            jjtree.clearNodeScope(jjtn006);
                            jjtc006 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte006 instanceof RuntimeException) {
                            throw (RuntimeException)jjte006;
                          }
                          if (jjte006 instanceof ParseException) {
                            throw (ParseException)jjte006;
                          }
                          throw (Error)jjte006;
                        } finally {
                          if (jjtc006) {
                            jjtree.closeNodeScope(jjtn006, true);
                            jjtreeCloseNodeScope(jjtn006);
                          }
                        }
/*@egen*/
  |	<CONTAINS>/*@bgen(jjtree) RoutineInvocation_GeoOp_Contain_Node */
                        {
                          SimpleNode jjtn007 = new SimpleNode(JJTROUTINEINVOCATION_GEOOP_CONTAIN_NODE);
                          boolean jjtc007 = true;
                          jjtree.openNodeScope(jjtn007);
                          jjtreeOpenNodeScope(jjtn007);
                        }
                        try {
/*@egen*/ 	GeoRoutineArgumentList()/*@bgen(jjtree)*/
                        } catch (Throwable jjte007) {
                          if (jjtc007) {
                            jjtree.clearNodeScope(jjtn007);
                            jjtc007 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte007 instanceof RuntimeException) {
                            throw (RuntimeException)jjte007;
                          }
                          if (jjte007 instanceof ParseException) {
                            throw (ParseException)jjte007;
                          }
                          throw (Error)jjte007;
                        } finally {
                          if (jjtc007) {
                            jjtree.closeNodeScope(jjtn007, true);
                            jjtreeCloseNodeScope(jjtn007);
                          }
                        }
/*@egen*/
  |	<OVERLAPS>/*@bgen(jjtree) RoutineInvocation_GeoOp_Overlap_Node */
                        {
                          SimpleNode jjtn008 = new SimpleNode(JJTROUTINEINVOCATION_GEOOP_OVERLAP_NODE);
                          boolean jjtc008 = true;
                          jjtree.openNodeScope(jjtn008);
                          jjtreeOpenNodeScope(jjtn008);
                        }
                        try {
/*@egen*/ 	GeoRoutineArgumentList()/*@bgen(jjtree)*/
                        } catch (Throwable jjte008) {
                          if (jjtc008) {
                            jjtree.clearNodeScope(jjtn008);
                            jjtc008 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte008 instanceof RuntimeException) {
                            throw (RuntimeException)jjte008;
                          }
                          if (jjte008 instanceof ParseException) {
                            throw (ParseException)jjte008;
                          }
                          throw (Error)jjte008;
                        } finally {
                          if (jjtc008) {
                            jjtree.closeNodeScope(jjtn008, true);
                            jjtreeCloseNodeScope(jjtn008);
                          }
                        }
/*@egen*/
  |	<RELATE>/*@bgen(jjtree) RoutineInvocation_GeoOp_Relate_Node */
                        {
                          SimpleNode jjtn009 = new SimpleNode(JJTROUTINEINVOCATION_GEOOP_RELATE_NODE);
                          boolean jjtc009 = true;
                          jjtree.openNodeScope(jjtn009);
                          jjtreeOpenNodeScope(jjtn009);
                        }
                        try {
/*@egen*/ 	RelateArgumentList()/*@bgen(jjtree)*/
                        } catch (Throwable jjte009) {
                          if (jjtc009) {
                            jjtree.clearNodeScope(jjtn009);
                            jjtc009 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte009 instanceof RuntimeException) {
                            throw (RuntimeException)jjte009;
                          }
                          if (jjte009 instanceof ParseException) {
                            throw (ParseException)jjte009;
                          }
                          throw (Error)jjte009;
                        } finally {
                          if (jjtc009) {
                            jjtree.closeNodeScope(jjtn009, true);
                            jjtreeCloseNodeScope(jjtn009);
                          }
                        }
/*@egen*/
  | <BBOX> 		BBoxArgumentList()		 
}

void RelateTail()      :
{}
{/*@bgen(jjtree) Relate_Node */
            {
              SimpleNode jjtn001 = new SimpleNode(JJTRELATE_NODE);
              boolean jjtc001 = true;
              jjtree.openNodeScope(jjtn001);
              jjtreeOpenNodeScope(jjtn001);
            }
            try {
/*@egen*/
	    <EOF>/*@bgen(jjtree)*/
            } finally {
              if (jjtc001) {
                jjtree.closeNodeScope(jjtn001, true);
                jjtreeCloseNodeScope(jjtn001);
              }
            }
/*@egen*/

}


void RelateArgumentList()      :
{}
{
    <LP> Attribute() <COMMA> GeometryLiteral() <COMMA> DE9IM() <RP>
}

void DE9IM()            :
{/*@bgen(jjtree) DE9IM_Node */
  SimpleNode jjtn000 = new SimpleNode(JJTDE9IM_NODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DE9IM_Node */
    try {
/*@egen*/
    <DE9IM_PATTERN>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}
/*
 *<relate pattern> ::=  <quote>
 *                        <relate flag><relate flag><relate flag><relate flag>
 *                        <relate flag><relate flag><relate flag><relate flag>
 *                        <relate flag>
 *                       <quote>
 * <relate flag> ::= "T" | "F" | "*" | "0" | "1" | "2"
 *
void Pattern9IM() #Pattern9IM_Node:
{}
{
	CharacterPattern()
}
*/

/*
 * <georoutine argument list> ::=
 *		<left paren><Expression><comma><Expression><right paren>
 *
 */
void GeoRoutineArgumentList()      :
{}
{
	<LP> Expression() <COMMA> Expression() <RP>
}

/*
 * <bbox argument list>::= 
 * 	  "(" <expression> "," <bounding box> ")" 
 * 	| "(" <expression> "," 
 * 		<min X> ","
 * 		<min Y> ","
 * 		<max X> ","
 * 		<max Y> 
 * 		[, srs] ")"
 * 
 * <min X> ::= <signed numerical literal> 
 * <min Y> ::= <signed numerical literal> 
 * <max X> ::= <signed numerical literal> 
 * <max Y> ::= <signed numerical literal> 
 * <srs> ::= <character string literal>
*/
void BBoxArgumentList()      :
{}
{
		<LP> Expression() <COMMA> BBoxArgListTail() 
}

void BBoxArgListTail()      :
{}
{
		BoundingBox()
	| 	(Function() | GeometryLiteral()) <RP>
	
} 

void BoundingBox()      :
{}
{
	 	NumericLiteral() <COMMA>
 		NumericLiteral() <COMMA>
 		NumericLiteral() <COMMA>
 		NumericLiteral() 
 	(/*@bgen(jjtree) RoutineInvocation_GeoOp_BBOX_Node */
                        {
                          SimpleNode jjtn001 = new SimpleNode(JJTROUTINEINVOCATION_GEOOP_BBOX_NODE);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                          jjtreeOpenNodeScope(jjtn001);
                        }
                        try {
/*@egen*/ 		<RP>/*@bgen(jjtree)*/
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001, true);
                            jjtreeCloseNodeScope(jjtn001);
                          }
                        }
/*@egen*/
  		| 	<COMMA> StringLiteral()/*@bgen(jjtree) RoutineInvocation_GeoOp_BBOX_SRS_Node */
                                               {
                                                 SimpleNode jjtn002 = new SimpleNode(JJTROUTINEINVOCATION_GEOOP_BBOX_SRS_NODE);
                                                 boolean jjtc002 = true;
                                                 jjtree.openNodeScope(jjtn002);
                                                 jjtreeOpenNodeScope(jjtn002);
                                               }
                                               try {
/*@egen*/<RP>/*@bgen(jjtree)*/
                                               } finally {
                                                 if (jjtc002) {
                                                   jjtree.closeNodeScope(jjtn002, true);
                                                   jjtreeCloseNodeScope(jjtn002);
                                                 }
                                               }
/*@egen*/)
}

/*
 * <relgeoop name> ::= DWITHIN | BEYOND
 */
void RoutineInvocationRelGeoOp()      :
{}
{
  	<DWITHIN>/*@bgen(jjtree) RoutineInvocation_RelOp_DWITHIN_Node */
                        {
                          SimpleNode jjtn001 = new SimpleNode(JJTROUTINEINVOCATION_RELOP_DWITHIN_NODE);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                          jjtreeOpenNodeScope(jjtn001);
                        }
                        try {
/*@egen*/ 	RelGeoRoutineArgumentList()/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001, true);
                            jjtreeCloseNodeScope(jjtn001);
                          }
                        }
/*@egen*/
  |	<BEYOND>/*@bgen(jjtree) RoutineInvocation_RelOp_BEYOND_Node */
                        {
                          SimpleNode jjtn002 = new SimpleNode(JJTROUTINEINVOCATION_RELOP_BEYOND_NODE);
                          boolean jjtc002 = true;
                          jjtree.openNodeScope(jjtn002);
                          jjtreeOpenNodeScope(jjtn002);
                        }
                        try {
/*@egen*/ 	RelGeoRoutineArgumentList()/*@bgen(jjtree)*/
                        } catch (Throwable jjte002) {
                          if (jjtc002) {
                            jjtree.clearNodeScope(jjtn002);
                            jjtc002 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte002 instanceof RuntimeException) {
                            throw (RuntimeException)jjte002;
                          }
                          if (jjte002 instanceof ParseException) {
                            throw (ParseException)jjte002;
                          }
                          throw (Error)jjte002;
                        } finally {
                          if (jjtc002) {
                            jjtree.closeNodeScope(jjtn002, true);
                            jjtreeCloseNodeScope(jjtn002);
                          }
                        }
/*@egen*/
}

/*
 * <relgeoop argument list> ::= 
 *		<left paren><attribute name><comma><geometry literal><comma><tolerance><right paren>
 */
void RelGeoRoutineArgumentList()      :
{}
{
	<LP> Expression() <COMMA> Expression() <COMMA> Tolerance() <RP>
	
//	<LP> Attribute() <COMMA> GeometryLiteral() <COMMA> Tolerance() <RP>
}
/*
 * <tolerance> ::= <unsigned numeric literal><comma><distance units>
 */
void Tolerance() :
{}
{/*@bgen(jjtree) Tolerance_Node */
        {
          SimpleNode jjtn001 = new SimpleNode(JJTTOLERANCE_NODE);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
          jjtreeOpenNodeScope(jjtn001);
        }
        try {
/*@egen*/
	UnsignedNumericLiteral()/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
            jjtreeCloseNodeScope(jjtn001);
          }
        }
/*@egen*/ <COMMA> DistanceUnits()
}

/**
 * <distance units> ::=
 *	 'feet' | 'meters' | 'statute miles' |
 *   'nautical miles' | 'kilometers'
 * 
 * TODO this set of units is just an example. The real list of distance unit must be developed
 */ 
void DistanceUnits()                    :
{/*@bgen(jjtree) DistanceUnits_Node */
  SimpleNode jjtn000 = new SimpleNode(JJTDISTANCEUNITS_NODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DistanceUnits_Node */
        try {
/*@egen*/
	<FEET> | <METERS> | <STATUTE_MILES> | <NAUTICAL_MILES> | <KILOMETERS>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/
}


/*
 * <geometry literal> ::= 
 *	  <Point Tagged Text>
 * 	| <LineString Tagged Text>
 * 	| <Polygon Tagged Text>
 *	| <MultiPoint Tagged Text>
 *  | <MultiLineString Tagged Text>
 * 	| <MultiPolygon Tagged Text>
 * 	| <GeometryCollection Tagged Text>
 *	| <Envelope Tagged Text>
 */
void GeometryLiteral()                 :
{/*@bgen(jjtree) GeometryLiteral */
  SimpleNode jjtn000 = new SimpleNode(JJTGEOMETRYLITERAL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) GeometryLiteral */
  try {
/*@egen*/
  PointTaggedText() |
  LineStringTaggedText() |
  PolygonTaggedText() |
  MultiPointTaggedText() |
  MultiLineStringTaggedText() |
  MultiPolygonTaggedText() |
  GeometryCollectionTaggedText() |
  EnvelopeTaggedText()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}
/*
 *  <routine invocation > ::= 
 *  |   <routine name > <argument list > 
 *                                           
 * <argument list&gt ::=    
 *      <left paren> [<positional arguments>] <right paren>
 * <positional arguments> ::=
 *      <argument> [ { <comma&gt <argument> }... ]
 *           
 * <argument>  ::= 
 *      <literal>  
 *  |   <attribute name>                                            
 *  |   <function>           (*Extension*)                                            
 *  |   <binary expression>  (*Extension*)                            
 */
void RoutineInvocationGeneric()      :
{}
{
	Function()
}

/* ---------------------------------------- *
 *   	End <routine invocation>
 * ---------------------------------------- *


/* ---------------------------------------- *
 *   	<includeexclude predicate>
 * ---------------------------------------- *
/*
 * <includeexclude predicate> ::= 
 *		  <INCLUDE> | <EXCLUDE>
 */
void IncludeExcludePredicate()      :
{}
{/*@bgen(jjtree) Include_Node */
   {
     SimpleNode jjtn001 = new SimpleNode(JJTINCLUDE_NODE);
     boolean jjtc001 = true;
     jjtree.openNodeScope(jjtn001);
     jjtreeOpenNodeScope(jjtn001);
   }
   try {
/*@egen*/
   <INCLUDE>/*@bgen(jjtree)*/
   } finally {
     if (jjtc001) {
       jjtree.closeNodeScope(jjtn001, true);
       jjtreeCloseNodeScope(jjtn001);
     }
   }
/*@egen*/
   |/*@bgen(jjtree) Exclude_Node */
     {
       SimpleNode jjtn002 = new SimpleNode(JJTEXCLUDE_NODE);
       boolean jjtc002 = true;
       jjtree.openNodeScope(jjtn002);
       jjtreeOpenNodeScope(jjtn002);
     }
     try {
/*@egen*/ <EXCLUDE>/*@bgen(jjtree)*/
     } finally {
       if (jjtc002) {
         jjtree.closeNodeScope(jjtn002, true);
         jjtreeCloseNodeScope(jjtn002);
       }
     }
/*@egen*/
}

/* ---------------------------------------- *
 *   	<comparison predicate>
 * ---------------------------------------- *
/*
 * <comparison predicate> ::= 
 *		  <attribute name> <comp op> <literal>
 */
void ComparisonPredicate() :
{}
{
   	 <EQ>/*@bgen(jjtree) ComparisonPredicate_EQ_Node */
                {
                  SimpleNode jjtn001 = new SimpleNode(JJTCOMPARISONPREDICATE_EQ_NODE);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                  jjtreeOpenNodeScope(jjtn001);
                }
                try {
/*@egen*/ 	Expression()/*@bgen(jjtree)*/
                } catch (Throwable jjte001) {
                  if (jjtc001) {
                    jjtree.clearNodeScope(jjtn001);
                    jjtc001 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte001 instanceof RuntimeException) {
                    throw (RuntimeException)jjte001;
                  }
                  if (jjte001 instanceof ParseException) {
                    throw (ParseException)jjte001;
                  }
                  throw (Error)jjte001;
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001, true);
                    jjtreeCloseNodeScope(jjtn001);
                  }
                }
/*@egen*/
   | <GT>/*@bgen(jjtree) ComparisonPredicate_GT_Node */
                {
                  SimpleNode jjtn002 = new SimpleNode(JJTCOMPARISONPREDICATE_GT_NODE);
                  boolean jjtc002 = true;
                  jjtree.openNodeScope(jjtn002);
                  jjtreeOpenNodeScope(jjtn002);
                }
                try {
/*@egen*/ 	Expression()/*@bgen(jjtree)*/
                } catch (Throwable jjte002) {
                  if (jjtc002) {
                    jjtree.clearNodeScope(jjtn002);
                    jjtc002 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte002 instanceof RuntimeException) {
                    throw (RuntimeException)jjte002;
                  }
                  if (jjte002 instanceof ParseException) {
                    throw (ParseException)jjte002;
                  }
                  throw (Error)jjte002;
                } finally {
                  if (jjtc002) {
                    jjtree.closeNodeScope(jjtn002, true);
                    jjtreeCloseNodeScope(jjtn002);
                  }
                }
/*@egen*/
   | <LT>/*@bgen(jjtree) ComparisonPredicate_LT_Node */
                {
                  SimpleNode jjtn003 = new SimpleNode(JJTCOMPARISONPREDICATE_LT_NODE);
                  boolean jjtc003 = true;
                  jjtree.openNodeScope(jjtn003);
                  jjtreeOpenNodeScope(jjtn003);
                }
                try {
/*@egen*/ 	Expression()/*@bgen(jjtree)*/
                } catch (Throwable jjte003) {
                  if (jjtc003) {
                    jjtree.clearNodeScope(jjtn003);
                    jjtc003 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte003 instanceof RuntimeException) {
                    throw (RuntimeException)jjte003;
                  }
                  if (jjte003 instanceof ParseException) {
                    throw (ParseException)jjte003;
                  }
                  throw (Error)jjte003;
                } finally {
                  if (jjtc003) {
                    jjtree.closeNodeScope(jjtn003, true);
                    jjtreeCloseNodeScope(jjtn003);
                  }
                }
/*@egen*/
   | <GTE>/*@bgen(jjtree) ComparisonPredicate_GTE_Node */
                {
                  SimpleNode jjtn004 = new SimpleNode(JJTCOMPARISONPREDICATE_GTE_NODE);
                  boolean jjtc004 = true;
                  jjtree.openNodeScope(jjtn004);
                  jjtreeOpenNodeScope(jjtn004);
                }
                try {
/*@egen*/ 	Expression()/*@bgen(jjtree)*/
                } catch (Throwable jjte004) {
                  if (jjtc004) {
                    jjtree.clearNodeScope(jjtn004);
                    jjtc004 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte004 instanceof RuntimeException) {
                    throw (RuntimeException)jjte004;
                  }
                  if (jjte004 instanceof ParseException) {
                    throw (ParseException)jjte004;
                  }
                  throw (Error)jjte004;
                } finally {
                  if (jjtc004) {
                    jjtree.closeNodeScope(jjtn004, true);
                    jjtreeCloseNodeScope(jjtn004);
                  }
                }
/*@egen*/
   | <LTE>/*@bgen(jjtree) ComparisonPredicate_LTE_Node */
                {
                  SimpleNode jjtn005 = new SimpleNode(JJTCOMPARISONPREDICATE_LTE_NODE);
                  boolean jjtc005 = true;
                  jjtree.openNodeScope(jjtn005);
                  jjtreeOpenNodeScope(jjtn005);
                }
                try {
/*@egen*/	Expression()/*@bgen(jjtree)*/
                } catch (Throwable jjte005) {
                  if (jjtc005) {
                    jjtree.clearNodeScope(jjtn005);
                    jjtc005 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte005 instanceof RuntimeException) {
                    throw (RuntimeException)jjte005;
                  }
                  if (jjte005 instanceof ParseException) {
                    throw (ParseException)jjte005;
                  }
                  throw (Error)jjte005;
                } finally {
                  if (jjtc005) {
                    jjtree.closeNodeScope(jjtn005, true);
                    jjtreeCloseNodeScope(jjtn005);
                  }
                }
/*@egen*/
   | <NEQ>/*@bgen(jjtree) ComparisonPredicate_Not_Equal_Node */
                {
                  SimpleNode jjtn006 = new SimpleNode(JJTCOMPARISONPREDICATE_NOT_EQUAL_NODE);
                  boolean jjtc006 = true;
                  jjtree.openNodeScope(jjtn006);
                  jjtreeOpenNodeScope(jjtn006);
                }
                try {
/*@egen*/ 	Expression()/*@bgen(jjtree)*/
                } catch (Throwable jjte006) {
                  if (jjtc006) {
                    jjtree.clearNodeScope(jjtn006);
                    jjtc006 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte006 instanceof RuntimeException) {
                    throw (RuntimeException)jjte006;
                  }
                  if (jjte006 instanceof ParseException) {
                    throw (ParseException)jjte006;
                  }
                  throw (Error)jjte006;
                } finally {
                  if (jjtc006) {
                    jjtree.closeNodeScope(jjtn006, true);
                    jjtreeCloseNodeScope(jjtn006);
                  }
                }
/*@egen*/
}

/*
 * <null predicate> ::= <attribute name> IS [ NOT ] NULL 
 */
void NullPredicate() :
{}
{
	  LOOKAHEAD(3) 	<IS>/*@bgen(jjtree) NullPredicateNode */
                             {
                               SimpleNode jjtn001 = new SimpleNode(JJTNULLPREDICATENODE);
                               boolean jjtc001 = true;
                               jjtree.openNodeScope(jjtn001);
                               jjtreeOpenNodeScope(jjtn001);
                             }
                             try {
/*@egen*/ <NULL>/*@bgen(jjtree)*/
                             } finally {
                               if (jjtc001) {
                                 jjtree.closeNodeScope(jjtn001, true);
                                 jjtreeCloseNodeScope(jjtn001);
                               }
                             }
/*@egen*/
	|  				<IS> <NOT>/*@bgen(jjtree) NotNullPredicateNode */
                                                   {
                                                     SimpleNode jjtn002 = new SimpleNode(JJTNOTNULLPREDICATENODE);
                                                     boolean jjtc002 = true;
                                                     jjtree.openNodeScope(jjtn002);
                                                     jjtreeOpenNodeScope(jjtn002);
                                                   }
                                                   try {
/*@egen*/ <NULL>/*@bgen(jjtree)*/
                                                   } finally {
                                                     if (jjtc002) {
                                                       jjtree.closeNodeScope(jjtn002, true);
                                                       jjtreeCloseNodeScope(jjtn002);
                                                     }
                                                   }
/*@egen*/
}


/* ---------------------------------------- *
 *   	<temporal predicate>
 * ---------------------------------------- *
 * <temporal predicate> ::= 
 *	  <attribute_name> TEQUALS <date-time expression>
 *	| <attribute_name> BEFORE <date-time expression>
 *	| <attribute_name> BEFORE OR DURING <period>
 *	| <attribute_name> DURING <period>
 *	| <attribute_name> DURING OR AFTER <period>
 *	| <attribute_name> AFTER <date-time expression>
 */
void TemporalPredicate()      :
{}
{
    TemporalPredicateHead() TemporalPredicateTail()
   
	
}

void TemporalPredicateHead()      :
{}
{
        Attribute()
   |    DateTime()
}

void TemporalPredicateTail()      :
{}
{
        <TEQUALS> TemporalPredicateTEquals()  
    |   <BEFORE> TemporalPredicateBefore()  
    |   <AFTER>  TemporalPredicateAfter()   
    |   <DURING> TemporalPredicateDuring()  
}

void TemporalPredicateTEquals()                        :
{/*@bgen(jjtree) TPTEQUALS_DateTime_Node */
  SimpleNode jjtn000 = new SimpleNode(JJTTPTEQUALS_DATETIME_NODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TPTEQUALS_DateTime_Node */
    try {
/*@egen*/
    DateTimeExpression()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/  
}

void TemporalPredicateBefore()     :
{}
{/*@bgen(jjtree) TPBefore_DateTime_Node */
                {
                  SimpleNode jjtn001 = new SimpleNode(JJTTPBEFORE_DATETIME_NODE);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                  jjtreeOpenNodeScope(jjtn001);
                }
                try {
/*@egen*/
		DateTimeExpression()/*@bgen(jjtree)*/
                } catch (Throwable jjte001) {
                  if (jjtc001) {
                    jjtree.clearNodeScope(jjtn001);
                    jjtc001 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte001 instanceof RuntimeException) {
                    throw (RuntimeException)jjte001;
                  }
                  if (jjte001 instanceof ParseException) {
                    throw (ParseException)jjte001;
                  }
                  throw (Error)jjte001;
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001, true);
                    jjtreeCloseNodeScope(jjtn001);
                  }
                }
/*@egen*/
	|	<OR> <DURING>/*@bgen(jjtree) TPBefore_Or_During_Period_Node */
                              {
                                SimpleNode jjtn002 = new SimpleNode(JJTTPBEFORE_OR_DURING_PERIOD_NODE);
                                boolean jjtc002 = true;
                                jjtree.openNodeScope(jjtn002);
                                jjtreeOpenNodeScope(jjtn002);
                              }
                              try {
/*@egen*/ Period()/*@bgen(jjtree)*/
                              } catch (Throwable jjte002) {
                                if (jjtc002) {
                                  jjtree.clearNodeScope(jjtn002);
                                  jjtc002 = false;
                                } else {
                                  jjtree.popNode();
                                }
                                if (jjte002 instanceof RuntimeException) {
                                  throw (RuntimeException)jjte002;
                                }
                                if (jjte002 instanceof ParseException) {
                                  throw (ParseException)jjte002;
                                }
                                throw (Error)jjte002;
                              } finally {
                                if (jjtc002) {
                                  jjtree.closeNodeScope(jjtn002, true);
                                  jjtreeCloseNodeScope(jjtn002);
                                }
                              }
/*@egen*/ 
}

void TemporalPredicateAfter()                       :
{/*@bgen(jjtree) TPAfter_DateTime_Node */
  SimpleNode jjtn000 = new SimpleNode(JJTTPAFTER_DATETIME_NODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TPAfter_DateTime_Node */
                try {
/*@egen*/
		DateTimeExpression()/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtreeCloseNodeScope(jjtn000);
                  }
                }
/*@egen*/
}

void TemporalPredicateDuring()      :
{}
{/*@bgen(jjtree) TPDuring_Period_Node */
                {
                  SimpleNode jjtn001 = new SimpleNode(JJTTPDURING_PERIOD_NODE);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                  jjtreeOpenNodeScope(jjtn001);
                }
                try {
/*@egen*/
		Period()/*@bgen(jjtree)*/
                } catch (Throwable jjte001) {
                  if (jjtc001) {
                    jjtree.clearNodeScope(jjtn001);
                    jjtc001 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte001 instanceof RuntimeException) {
                    throw (RuntimeException)jjte001;
                  }
                  if (jjte001 instanceof ParseException) {
                    throw (ParseException)jjte001;
                  }
                  throw (Error)jjte001;
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001, true);
                    jjtreeCloseNodeScope(jjtn001);
                  }
                }
/*@egen*/
	| 	<OR> <AFTER>/*@bgen(jjtree) TPDuring_Or_After_Period_Node */
                             {
                               SimpleNode jjtn002 = new SimpleNode(JJTTPDURING_OR_AFTER_PERIOD_NODE);
                               boolean jjtc002 = true;
                               jjtree.openNodeScope(jjtn002);
                               jjtreeOpenNodeScope(jjtn002);
                             }
                             try {
/*@egen*/ Period()/*@bgen(jjtree)*/
                             } catch (Throwable jjte002) {
                               if (jjtc002) {
                                 jjtree.clearNodeScope(jjtn002);
                                 jjtc002 = false;
                               } else {
                                 jjtree.popNode();
                               }
                               if (jjte002 instanceof RuntimeException) {
                                 throw (RuntimeException)jjte002;
                               }
                               if (jjte002 instanceof ParseException) {
                                 throw (ParseException)jjte002;
                               }
                               throw (Error)jjte002;
                             } finally {
                               if (jjtc002) {
                                 jjtree.closeNodeScope(jjtn002, true);
                                 jjtreeCloseNodeScope(jjtn002);
                               }
                             }
/*@egen*/
}

/*
 * <date-time expression ::= <date-time> | <period>
 */
void DateTimeExpression()      :
{}
{
		LOOKAHEAD(2) Period() 	
	| 	DateTime()						
}

/*
 *<period> ::= 
 *	  <date-time> "/" <date-time>
 * 	| <date-time> "/" <duration>
 * 	| <duration> "/" <date-time>
 */
void Period()      :
{}
{
		LOOKAHEAD(2)
		DateTime() <SLASH> PeriodTail() 	
	|	Duration() <SLASH>/*@bgen(jjtree) Period_With_Duration_Date_Node */
                                   {
                                     SimpleNode jjtn001 = new SimpleNode(JJTPERIOD_WITH_DURATION_DATE_NODE);
                                     boolean jjtc001 = true;
                                     jjtree.openNodeScope(jjtn001);
                                     jjtreeOpenNodeScope(jjtn001);
                                   }
                                   try {
/*@egen*/ DateTime()/*@bgen(jjtree)*/
                                   } catch (Throwable jjte001) {
                                     if (jjtc001) {
                                       jjtree.clearNodeScope(jjtn001);
                                       jjtc001 = false;
                                     } else {
                                       jjtree.popNode();
                                     }
                                     if (jjte001 instanceof RuntimeException) {
                                       throw (RuntimeException)jjte001;
                                     }
                                     if (jjte001 instanceof ParseException) {
                                       throw (ParseException)jjte001;
                                     }
                                     throw (Error)jjte001;
                                   } finally {
                                     if (jjtc001) {
                                       jjtree.closeNodeScope(jjtn001, true);
                                       jjtreeCloseNodeScope(jjtn001);
                                     }
                                   }
/*@egen*/
}

void PeriodTail()     :
{}
{/*@bgen(jjtree) Period_With_Date_Duration_Node */
                {
                  SimpleNode jjtn001 = new SimpleNode(JJTPERIOD_WITH_DATE_DURATION_NODE);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                  jjtreeOpenNodeScope(jjtn001);
                }
                try {
/*@egen*/
		Duration()/*@bgen(jjtree)*/
                } catch (Throwable jjte001) {
                  if (jjtc001) {
                    jjtree.clearNodeScope(jjtn001);
                    jjtc001 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte001 instanceof RuntimeException) {
                    throw (RuntimeException)jjte001;
                  }
                  if (jjte001 instanceof ParseException) {
                    throw (ParseException)jjte001;
                  }
                  throw (Error)jjte001;
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001, true);
                    jjtreeCloseNodeScope(jjtn001);
                  }
                }
/*@egen*/
	|/*@bgen(jjtree) Period_Between_Dates_Node */
                {
                  SimpleNode jjtn002 = new SimpleNode(JJTPERIOD_BETWEEN_DATES_NODE);
                  boolean jjtc002 = true;
                  jjtree.openNodeScope(jjtn002);
                  jjtreeOpenNodeScope(jjtn002);
                }
                try {
/*@egen*/	DateTime()/*@bgen(jjtree)*/
                } catch (Throwable jjte002) {
                  if (jjtc002) {
                    jjtree.clearNodeScope(jjtn002);
                    jjtc002 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte002 instanceof RuntimeException) {
                    throw (RuntimeException)jjte002;
                  }
                  if (jjte002 instanceof ParseException) {
                    throw (ParseException)jjte002;
                  }
                  throw (Error)jjte002;
                } finally {
                  if (jjtc002) {
                    jjtree.closeNodeScope(jjtn002, true);
                    jjtreeCloseNodeScope(jjtn002);
                  }
                }
/*@egen*/	
}

void DateTime()               : 
{/*@bgen(jjtree) DateTime_Node */
  SimpleNode jjtn000 = new SimpleNode(JJTDATETIME_NODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DateTime_Node */
        try {
/*@egen*/
	<DATE_TIME>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/ 
}


/*
 * <duration> ::= "P" <dur-date> | <dur-time>
 * <dur-date> ::= <dur-day> | <dur-month> | <dur-year> [<dur-time>]
 * <dur-day> ::= <digit>... "D"
 * <dur-month> ::= <digit>... "M" [<dur-day>]
 * <dur-year> ::= <didit>... "Y" [<dur-month>]
 */
void Duration()     :
{}
{/*@bgen(jjtree) Duration_Date_Node */
                {
                  SimpleNode jjtn001 = new SimpleNode(JJTDURATION_DATE_NODE);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                  jjtreeOpenNodeScope(jjtn001);
                }
                try {
/*@egen*/
 		<DURATION>/*@bgen(jjtree)*/
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001, true);
                    jjtreeCloseNodeScope(jjtn001);
                  }
                }
/*@egen*/
}

/* ---------------------------------------- *
 *  End <temporal predicate>
 * ---------------------------------------- */

/* ---------------------------------------- *
 *  <existence predicate>
 * ---------------------------------------- */
/*
 * <existence_predicate> ::= <attribute_name> EXISTS
 * | <attribute_name> DOES-NOT-EXIST
 */
void ExistencePredicate()      :
{}
{/*@bgen(jjtree) Existence_Predicate_Exists_Node */
                {
                  SimpleNode jjtn001 = new SimpleNode(JJTEXISTENCE_PREDICATE_EXISTS_NODE);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                  jjtreeOpenNodeScope(jjtn001);
                }
                try {
/*@egen*/
		<EXISTS>/*@bgen(jjtree)*/
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001, true);
                    jjtreeCloseNodeScope(jjtn001);
                  }
                }
/*@egen*/
	|/*@bgen(jjtree) Existence_Predicate_DoesNotExist_Node */
                {
                  SimpleNode jjtn002 = new SimpleNode(JJTEXISTENCE_PREDICATE_DOESNOTEXIST_NODE);
                  boolean jjtc002 = true;
                  jjtree.openNodeScope(jjtn002);
                  jjtreeOpenNodeScope(jjtn002);
                }
                try {
/*@egen*/	<DOES_NOT_EXIST>/*@bgen(jjtree)*/
                } finally {
                  if (jjtc002) {
                    jjtree.closeNodeScope(jjtn002, true);
                    jjtreeCloseNodeScope(jjtn002);
                  }
                }
/*@egen*/
}
/* ---------------------------------------- *
 *  end <existence predicate>
 * ---------------------------------------- */

void likePredicate()      :
{}
{
  	 	LOOKAHEAD(2)  <NOT> <LIKE>/*@bgen(jjtree) Not_Like_Node */
                                           {
                                             SimpleNode jjtn001 = new SimpleNode(JJTNOT_LIKE_NODE);
                                             boolean jjtc001 = true;
                                             jjtree.openNodeScope(jjtn001);
                                             jjtreeOpenNodeScope(jjtn001);
                                           }
                                           try {
/*@egen*/ CharacterPattern()/*@bgen(jjtree)*/
                                           } catch (Throwable jjte001) {
                                             if (jjtc001) {
                                               jjtree.clearNodeScope(jjtn001);
                                               jjtc001 = false;
                                             } else {
                                               jjtree.popNode();
                                             }
                                             if (jjte001 instanceof RuntimeException) {
                                               throw (RuntimeException)jjte001;
                                             }
                                             if (jjte001 instanceof ParseException) {
                                               throw (ParseException)jjte001;
                                             }
                                             throw (Error)jjte001;
                                           } finally {
                                             if (jjtc001) {
                                               jjtree.closeNodeScope(jjtn001, true);
                                               jjtreeCloseNodeScope(jjtn001);
                                             }
                                           }
/*@egen*/
  	|	              <LIKE>/*@bgen(jjtree) Like_Node */
                                     {
                                       SimpleNode jjtn002 = new SimpleNode(JJTLIKE_NODE);
                                       boolean jjtc002 = true;
                                       jjtree.openNodeScope(jjtn002);
                                       jjtreeOpenNodeScope(jjtn002);
                                     }
                                     try {
/*@egen*/ CharacterPattern()/*@bgen(jjtree)*/
                                     } catch (Throwable jjte002) {
                                       if (jjtc002) {
                                         jjtree.clearNodeScope(jjtn002);
                                         jjtc002 = false;
                                       } else {
                                         jjtree.popNode();
                                       }
                                       if (jjte002 instanceof RuntimeException) {
                                         throw (RuntimeException)jjte002;
                                       }
                                       if (jjte002 instanceof ParseException) {
                                         throw (ParseException)jjte002;
                                       }
                                       throw (Error)jjte002;
                                     } finally {
                                       if (jjtc002) {
                                         jjtree.closeNodeScope(jjtn002, true);
                                         jjtreeCloseNodeScope(jjtn002);
                                       }
                                     }
/*@egen*/
}

void IlikePredicate()      :
{}
{
  	 	LOOKAHEAD(2)  <NOT> <ILIKE>/*@bgen(jjtree) Not_ILike_Node */
                                            {
                                              SimpleNode jjtn001 = new SimpleNode(JJTNOT_ILIKE_NODE);
                                              boolean jjtc001 = true;
                                              jjtree.openNodeScope(jjtn001);
                                              jjtreeOpenNodeScope(jjtn001);
                                            }
                                            try {
/*@egen*/ CharacterPattern()/*@bgen(jjtree)*/
                                            } catch (Throwable jjte001) {
                                              if (jjtc001) {
                                                jjtree.clearNodeScope(jjtn001);
                                                jjtc001 = false;
                                              } else {
                                                jjtree.popNode();
                                              }
                                              if (jjte001 instanceof RuntimeException) {
                                                throw (RuntimeException)jjte001;
                                              }
                                              if (jjte001 instanceof ParseException) {
                                                throw (ParseException)jjte001;
                                              }
                                              throw (Error)jjte001;
                                            } finally {
                                              if (jjtc001) {
                                                jjtree.closeNodeScope(jjtn001, true);
                                                jjtreeCloseNodeScope(jjtn001);
                                              }
                                            }
/*@egen*/
  	|	              <ILIKE>/*@bgen(jjtree) ILike_Node */
                                      {
                                        SimpleNode jjtn002 = new SimpleNode(JJTILIKE_NODE);
                                        boolean jjtc002 = true;
                                        jjtree.openNodeScope(jjtn002);
                                        jjtreeOpenNodeScope(jjtn002);
                                      }
                                      try {
/*@egen*/ CharacterPattern()/*@bgen(jjtree)*/
                                      } catch (Throwable jjte002) {
                                        if (jjtc002) {
                                          jjtree.clearNodeScope(jjtn002);
                                          jjtc002 = false;
                                        } else {
                                          jjtree.popNode();
                                        }
                                        if (jjte002 instanceof RuntimeException) {
                                          throw (RuntimeException)jjte002;
                                        }
                                        if (jjte002 instanceof ParseException) {
                                          throw (ParseException)jjte002;
                                        }
                                        throw (Error)jjte002;
                                      } finally {
                                        if (jjtc002) {
                                          jjtree.closeNodeScope(jjtn002, true);
                                          jjtreeCloseNodeScope(jjtn002);
                                        }
                                      }
/*@egen*/
}

void CharacterPattern()      :
{}
{
  	StringLiteral() 
}

/*
 * Cql Extension
 * 
 *	<beween predicate>::= ["NOT"] "BETWEEN" expression "AND" expression
 */
void BetweenPredicate()      :
{}
{
	LOOKAHEAD(2) <NOT> <BETWEEN> Expression() <AND>/*@bgen(jjtree) Not_Between_Node */
                                                        {
                                                          SimpleNode jjtn001 = new SimpleNode(JJTNOT_BETWEEN_NODE);
                                                          boolean jjtc001 = true;
                                                          jjtree.openNodeScope(jjtn001);
                                                          jjtreeOpenNodeScope(jjtn001);
                                                        }
                                                        try {
/*@egen*/ Expression()/*@bgen(jjtree)*/
                                                        } catch (Throwable jjte001) {
                                                          if (jjtc001) {
                                                            jjtree.clearNodeScope(jjtn001);
                                                            jjtc001 = false;
                                                          } else {
                                                            jjtree.popNode();
                                                          }
                                                          if (jjte001 instanceof RuntimeException) {
                                                            throw (RuntimeException)jjte001;
                                                          }
                                                          if (jjte001 instanceof ParseException) {
                                                            throw (ParseException)jjte001;
                                                          }
                                                          throw (Error)jjte001;
                                                        } finally {
                                                          if (jjtc001) {
                                                            jjtree.closeNodeScope(jjtn001, true);
                                                            jjtreeCloseNodeScope(jjtn001);
                                                          }
                                                        }
/*@egen*/
  	|			 <BETWEEN> Expression() <AND>/*@bgen(jjtree) Between_Node */
                                                              {
                                                                SimpleNode jjtn002 = new SimpleNode(JJTBETWEEN_NODE);
                                                                boolean jjtc002 = true;
                                                                jjtree.openNodeScope(jjtn002);
                                                                jjtreeOpenNodeScope(jjtn002);
                                                              }
                                                              try {
/*@egen*/ Expression()/*@bgen(jjtree)*/
                                                              } catch (Throwable jjte002) {
                                                                if (jjtc002) {
                                                                  jjtree.clearNodeScope(jjtn002);
                                                                  jjtc002 = false;
                                                                } else {
                                                                  jjtree.popNode();
                                                                }
                                                                if (jjte002 instanceof RuntimeException) {
                                                                  throw (RuntimeException)jjte002;
                                                                }
                                                                if (jjte002 instanceof ParseException) {
                                                                  throw (ParseException)jjte002;
                                                                }
                                                                throw (Error)jjte002;
                                                              } finally {
                                                                if (jjtc002) {
                                                                  jjtree.closeNodeScope(jjtn002, true);
                                                                  jjtreeCloseNodeScope(jjtn002);
                                                                }
                                                              }
/*@egen*/
}

/*
 * cql extension
 *	<expression> ::= 
 */
void Expression()      :
{}
{
   		BinaryExpression()
   	|  	GeometryLiteral()
}

void BinaryExpression()      :
{}
{
  MultiplicativeExpression()
  (
    <PLUS>/*@bgen(jjtree) AddNode */
           {
             SimpleNode jjtn001 = new SimpleNode(JJTADDNODE);
             boolean jjtc001 = true;
             jjtree.openNodeScope(jjtn001);
             jjtreeOpenNodeScope(jjtn001);
           }
           try {
/*@egen*/ MultiplicativeExpression()/*@bgen(jjtree)*/
           } catch (Throwable jjte001) {
             if (jjtc001) {
               jjtree.clearNodeScope(jjtn001);
               jjtc001 = false;
             } else {
               jjtree.popNode();
             }
             if (jjte001 instanceof RuntimeException) {
               throw (RuntimeException)jjte001;
             }
             if (jjte001 instanceof ParseException) {
               throw (ParseException)jjte001;
             }
             throw (Error)jjte001;
           } finally {
             if (jjtc001) {
               jjtree.closeNodeScope(jjtn001, true);
               jjtreeCloseNodeScope(jjtn001);
             }
           }
/*@egen*/
   |
    <MINUS>/*@bgen(jjtree) SubtractNode */
            {
              SimpleNode jjtn002 = new SimpleNode(JJTSUBTRACTNODE);
              boolean jjtc002 = true;
              jjtree.openNodeScope(jjtn002);
              jjtreeOpenNodeScope(jjtn002);
            }
            try {
/*@egen*/ MultiplicativeExpression()/*@bgen(jjtree)*/
            } catch (Throwable jjte002) {
              if (jjtc002) {
                jjtree.clearNodeScope(jjtn002);
                jjtc002 = false;
              } else {
                jjtree.popNode();
              }
              if (jjte002 instanceof RuntimeException) {
                throw (RuntimeException)jjte002;
              }
              if (jjte002 instanceof ParseException) {
                throw (ParseException)jjte002;
              }
              throw (Error)jjte002;
            } finally {
              if (jjtc002) {
                jjtree.closeNodeScope(jjtn002, true);
                jjtreeCloseNodeScope(jjtn002);
              }
            }
/*@egen*/
  )*
}
 


void MultiplicativeExpression()       :
{}
{
  
  UnaryExpression()
  (
    <MULT>/*@bgen(jjtree) MulNode */
           {
             SimpleNode jjtn001 = new SimpleNode(JJTMULNODE);
             boolean jjtc001 = true;
             jjtree.openNodeScope(jjtn001);
             jjtreeOpenNodeScope(jjtn001);
           }
           try {
/*@egen*/ UnaryExpression()/*@bgen(jjtree)*/
           } catch (Throwable jjte001) {
             if (jjtc001) {
               jjtree.clearNodeScope(jjtn001);
               jjtc001 = false;
             } else {
               jjtree.popNode();
             }
             if (jjte001 instanceof RuntimeException) {
               throw (RuntimeException)jjte001;
             }
             if (jjte001 instanceof ParseException) {
               throw (ParseException)jjte001;
             }
             throw (Error)jjte001;
           } finally {
             if (jjtc001) {
               jjtree.closeNodeScope(jjtn001, true);
               jjtreeCloseNodeScope(jjtn001);
             }
           }
/*@egen*/
   |
    <SLASH>/*@bgen(jjtree) DivNode */
            {
              SimpleNode jjtn002 = new SimpleNode(JJTDIVNODE);
              boolean jjtc002 = true;
              jjtree.openNodeScope(jjtn002);
              jjtreeOpenNodeScope(jjtn002);
            }
            try {
/*@egen*/ UnaryExpression()/*@bgen(jjtree)*/
            } catch (Throwable jjte002) {
              if (jjtc002) {
                jjtree.clearNodeScope(jjtn002);
                jjtc002 = false;
              } else {
                jjtree.popNode();
              }
              if (jjte002 instanceof RuntimeException) {
                throw (RuntimeException)jjte002;
              }
              if (jjte002 instanceof ParseException) {
                throw (ParseException)jjte002;
              }
              throw (Error)jjte002;
            } finally {
              if (jjtc002) {
                jjtree.closeNodeScope(jjtn002, true);
                jjtreeCloseNodeScope(jjtn002);
              }
            }
/*@egen*/
  )*
}

void UnaryExpression()      :
{}
{
	  LOOKAHEAD(2)<LP> Expression()<RP>
	| LOOKAHEAD(2)<LSP> Expression()<RSP>
	| LOOKAHEAD(2) Function() 
	| Literal()
	| Attribute()
}

void Evaluate()      :
{}
{
  	LOOKAHEAD(2) Function() 
  |	Attribute()
}

/*
 * <identifier> ::= <identifier part [ { <colon> | <identifier part> }... ]
 */
void Identifier()                 :
{/*@bgen(jjtree) Identifier_Node */
  SimpleNode jjtn000 = new SimpleNode(JJTIDENTIFIER_NODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Identifier_Node */
        try {
/*@egen*/
	IdentifierPart() ( <COLON> | IdentifierPart() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/	
}
void IdentifierPart()                      :
 {/*@bgen(jjtree) Identifier_Part_Node */
  SimpleNode jjtn000 = new SimpleNode(JJTIDENTIFIER_PART_NODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
 {/*@bgen(jjtree) Identifier_Part_Node */
        try {
/*@egen*/
	<IDENTIFIER>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/
 }
 
   
/*
 * <attribute name> ::= 
 *  	  <simple attribute name> 
 * 		| <compound attribute name>
 * 
 * <compound attribute name> ::= 
 * 		<identifier><period> [{<identifier><period>}*] <simple attribute name>
 *
 * <simple attribute name> ::= <identifier>
 */ 
void Attribute()      :
{}
{
	 	SimpleAttributeName() AttributeTail() 
}

/*
 * <simple attribute name> ::= <identifier>
 */
void SimpleAttributeName()                       :
{/*@bgen(jjtree) Simple_Attribute_Node */
  SimpleNode jjtn000 = new SimpleNode(JJTSIMPLE_ATTRIBUTE_NODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Simple_Attribute_Node */
        try {
/*@egen*/
	Identifier()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/	
}

void AttributeTail()                         :
{/*@bgen(jjtree) Compound_Attribute_Node */
  SimpleNode jjtn000 = new SimpleNode(JJTCOMPOUND_ATTRIBUTE_NODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Compound_Attribute_Node */
         try {
/*@egen*/
 	 (  <PERIOD> SimpleAttributeName() )*/*@bgen(jjtree)*/
         } catch (Throwable jjte000) {
           if (jjtc000) {
             jjtree.clearNodeScope(jjtn000);
             jjtc000 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte000 instanceof RuntimeException) {
             throw (RuntimeException)jjte000;
           }
           if (jjte000 instanceof ParseException) {
             throw (ParseException)jjte000;
           }
           throw (Error)jjte000;
         } finally {
           if (jjtc000) {
             jjtree.closeNodeScope(jjtn000, true);
             jjtreeCloseNodeScope(jjtn000);
           }
         }
/*@egen*/ 
}

/*
 * <literal> ::= 
 *			<signed numeric literal>
 * 		| 	<general literal>
 */
void Literal()       :
{}
{
		DateLiteral()
	|  	NumericLiteral()
	| 	GeneralLiteral()	
}

void DateLiteral()       :
{}
{/*@bgen(jjtree) Date_Node */
    {
      SimpleNode jjtn001 = new SimpleNode(JJTDATE_NODE);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtreeOpenNodeScope(jjtn001);
    }
    try {
/*@egen*/
    <DATE>/*@bgen(jjtree)*/
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
        jjtreeCloseNodeScope(jjtn001);
      }
    }
/*@egen*/
  |/*@bgen(jjtree) DateTime_Node */
    {
      SimpleNode jjtn002 = new SimpleNode(JJTDATETIME_NODE);
      boolean jjtc002 = true;
      jjtree.openNodeScope(jjtn002);
      jjtreeOpenNodeScope(jjtn002);
    }
    try {
/*@egen*/ <DATE_TIME>/*@bgen(jjtree)*/
    } finally {
      if (jjtc002) {
        jjtree.closeNodeScope(jjtn002, true);
        jjtreeCloseNodeScope(jjtn002);
      }
    }
/*@egen*/
}

void NumericLiteral()       :
{}
{/*@bgen(jjtree) NegativeNumber_Node */
                {
                  SimpleNode jjtn001 = new SimpleNode(JJTNEGATIVENUMBER_NODE);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                  jjtreeOpenNodeScope(jjtn001);
                }
                try {
/*@egen*/
		(("-") UnsignedNumericLiteral())/*@bgen(jjtree)*/
                } catch (Throwable jjte001) {
                  if (jjtc001) {
                    jjtree.clearNodeScope(jjtn001);
                    jjtc001 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte001 instanceof RuntimeException) {
                    throw (RuntimeException)jjte001;
                  }
                  if (jjte001 instanceof ParseException) {
                    throw (ParseException)jjte001;
                  }
                  throw (Error)jjte001;
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001, true);
                    jjtreeCloseNodeScope(jjtn001);
                  }
                }
/*@egen*/ 
	| 	UnsignedNumericLiteral() 

}
void UnsignedNumericLiteral()       :
{}
{
		IntegerLiteral() 
  	| 	FloatingLiteral() 
}

/*
 *<general literal> ::= 
 * 			<character string literal>
 * 		| 	<datetime literal>
 * 		| 	<boolean literal>
 * 		| 	<geography literal
 */   
void GeneralLiteral()      :
{}
{
  	StringLiteral()
  |	BooleanLiteral() 
//  | GeographyLiteral()  TODO
}



void IntegerLiteral()             :
{/*@bgen(jjtree) IntegerNode */
  SimpleNode jjtn000 = new SimpleNode(JJTINTEGERNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) IntegerNode */
  try {
/*@egen*/
  <INTEGER_LITERAL>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void FloatingLiteral()              :
{/*@bgen(jjtree) FloatingNode */
  SimpleNode jjtn000 = new SimpleNode(JJTFLOATINGNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FloatingNode */
  try {
/*@egen*/
  <FLOATING_LITERAL>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void BooleanLiteral()       :
{}
{/*@bgen(jjtree) TrueNode */
  {
    SimpleNode jjtn001 = new SimpleNode(JJTTRUENODE);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);
  }
  try {
/*@egen*/
  <TRUE>/*@bgen(jjtree)*/
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
      jjtreeCloseNodeScope(jjtn001);
    }
  }
/*@egen*/ |/*@bgen(jjtree) FalseNode */
  {
    SimpleNode jjtn002 = new SimpleNode(JJTFALSENODE);
    boolean jjtc002 = true;
    jjtree.openNodeScope(jjtn002);
    jjtreeOpenNodeScope(jjtn002);
  }
  try {
/*@egen*/
  <FALSE>/*@bgen(jjtree)*/
  } finally {
    if (jjtc002) {
      jjtree.closeNodeScope(jjtn002, true);
      jjtreeCloseNodeScope(jjtn002);
    }
  }
/*@egen*/
}

void StringLiteral()             :
{/*@bgen(jjtree) StringNode */
  SimpleNode jjtn000 = new SimpleNode(JJTSTRINGNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StringNode */
    try {
/*@egen*/
    <STRING_LITERAL>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/ 
}

/* ---------------------------------------- *
 *  <function>
 * ---------------------------------------- */
/*
 * <function> ::= <identifier> "("<function arg> [,<function arg>]*)
 */
void Function()               :
{/*@bgen(jjtree) Function_Node */
  SimpleNode jjtn000 = new SimpleNode(JJTFUNCTION_NODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Function_Node */
                 try {
/*@egen*/
  		 FunctionName()
  			<LP>( FunctionArg() (<COMMA> FunctionArg() )* )? <RP>/*@bgen(jjtree)*/
                 } catch (Throwable jjte000) {
                   if (jjtc000) {
                     jjtree.clearNodeScope(jjtn000);
                     jjtc000 = false;
                   } else {
                     jjtree.popNode();
                   }
                   if (jjte000 instanceof RuntimeException) {
                     throw (RuntimeException)jjte000;
                   }
                   if (jjte000 instanceof ParseException) {
                     throw (ParseException)jjte000;
                   }
                   throw (Error)jjte000;
                 } finally {
                   if (jjtc000) {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtreeCloseNodeScope(jjtn000);
                   }
                 }
/*@egen*/
}


void FunctionName()                   :
{/*@bgen(jjtree) FunctionName_Node */
  SimpleNode jjtn000 = new SimpleNode(JJTFUNCTIONNAME_NODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FunctionName_Node */
    try {
/*@egen*/
    <IDENTIFIER>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

/*
 * <argument>  ::= 
 *      <literal>  
 *  |   <attribute name>                                            
 * 	|	<expression> (*extension: expresion inclue literal and attributes*) 
 */
void FunctionArg()                  :
{/*@bgen(jjtree) FunctionArg_Node */
  SimpleNode jjtn000 = new SimpleNode(JJTFUNCTIONARG_NODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FunctionArg_Node */
                try {
/*@egen*/
		Expression()/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtreeCloseNodeScope(jjtn000);
                  }
                }
/*@egen*/
}
/* ---------------------------------------- *
 *  end <function>
 * ---------------------------------------- */

/*
 * <Point> := <x><space><y>
 */
void Point()            :
{/*@bgen(jjtree) Point_Node */
  SimpleNode jjtn000 = new SimpleNode(JJTPOINT_NODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Point_Node */
  try {
/*@egen*/
  NumericLiteral() NumericLiteral()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

/*
 * <LineString Text> := EMPTY
 * | <left paren><Point>{<comma><Point >} ... <right paren>
 */
void LineStringText()                     :
{/*@bgen(jjtree) LineStringText_Node */
  SimpleNode jjtn000 = new SimpleNode(JJTLINESTRINGTEXT_NODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) LineStringText_Node */
  try {
/*@egen*/
  (<LP> Point() ( <COMMA> Point() )* <RP>)?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void PointTaggedText()         :
{/*@bgen(jjtree) WKTNode */
  SimpleNode jjtn000 = new SimpleNode(JJTWKTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/} 
{/*@bgen(jjtree) WKTNode */
   try {
/*@egen*/
   <POINT> PointText()/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
   }
/*@egen*/
}
/*
 * <Point Text> := EMPTY | <left paren> <Point> <right paren>
 */
void PointText()                :
{/*@bgen(jjtree) PointText_Node */
  SimpleNode jjtn000 = new SimpleNode(JJTPOINTTEXT_NODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PointText_Node */
        try {
/*@egen*/
	(<LP> Point() <RP>)?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/
}

void LineStringTaggedText()         :
{/*@bgen(jjtree) WKTNode */
  SimpleNode jjtn000 = new SimpleNode(JJTWKTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) WKTNode */
   try {
/*@egen*/
   <LINESTRING> LineStringText()/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
   }
/*@egen*/ 
}
/*
 * <Polygon Tagged Text> := POLYGON <Polygon Text>
 */
void PolygonTaggedText()         :
{/*@bgen(jjtree) WKTNode */
  SimpleNode jjtn000 = new SimpleNode(JJTWKTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) WKTNode */
  try {
/*@egen*/
  <POLYGON> PolygonText()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}


/*
 * <Polygon Text> := EMPTY
 *  	| <left paren><LineString Text>{<comma><LineString Text>}*<right paren>
 */
void PolygonText()                 :
{/*@bgen(jjtree) PolygonText_Node */
  SimpleNode jjtn000 = new SimpleNode(JJTPOLYGONTEXT_NODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PolygonText_Node */
        try {
/*@egen*/
	(<LP> LineStringText() (<COMMA> LineStringText())* <RP>)?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/
}

/*
 * <MultiPoint Tagged Text> ::= MULTIPOINT <Multipoint Text>
 */
void MultiPointTaggedText()         :
{/*@bgen(jjtree) WKTNode */
  SimpleNode jjtn000 = new SimpleNode(JJTWKTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) WKTNode */
  try {
/*@egen*/
  <MULTIPOINT> MultiPointText()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}
/*
 * <Multipoint Text> := EMPTY
 * 	| ( <Point Text > {, <Point Text > }* )
 */
void MultiPointText()                     :
{/*@bgen(jjtree) MultiPointText_Node */
  SimpleNode jjtn000 = new SimpleNode(JJTMULTIPOINTTEXT_NODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MultiPointText_Node */
        try {
/*@egen*/
 	(<LP> PointText() (<COMMA> PointText() )* <RP>)?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/
}

/*
 * <MultiLineString Tagged Text> := MULTILINESTRING <MultiLineString Text>
 */
void MultiLineStringTaggedText()         :
{/*@bgen(jjtree) WKTNode */
  SimpleNode jjtn000 = new SimpleNode(JJTWKTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) WKTNode */
  try {
/*@egen*/
  <MULTILINESTRING> MultiLineStringText()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}
/*
 * <MultiLineString Text> := 
 *		EMPTY
 * 		| ( <LineString Text > {, < LineString Text > }* )
 */
void MultiLineStringText()                          :
{/*@bgen(jjtree) MultiLineStringText_Node */
  SimpleNode jjtn000 = new SimpleNode(JJTMULTILINESTRINGTEXT_NODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MultiLineStringText_Node */
        try {
/*@egen*/
	( <LP> LineStringText() (<COMMA> LineStringText())* <RP> )?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/
}
/*
 * <MultiPolygon Tagged Text> :: =MULTIPOLYGON <MultiPolygon Text>
 */
void MultiPolygonTaggedText()         :
{/*@bgen(jjtree) WKTNode */
  SimpleNode jjtn000 = new SimpleNode(JJTWKTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) WKTNode */
  try {
/*@egen*/
  <MULTIPOLYGON> MultiPolygonText()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}
/*
 * <MultiPolygon Text> := EMPTY
 * 	| <left paren><Polygon Text>{<comma><Polygon Text>}* <right paren>
 */
void MultiPolygonText()                       :
{/*@bgen(jjtree) MultiPolygonText_Node */
  SimpleNode jjtn000 = new SimpleNode(JJTMULTIPOLYGONTEXT_NODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MultiPolygonText_Node */
        try {
/*@egen*/
	( <LP> PolygonText() ( <COMMA> PolygonText() )* <RP> )?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/
}

void GeometryCollectionTaggedText()         :
{/*@bgen(jjtree) WKTNode */
  SimpleNode jjtn000 = new SimpleNode(JJTWKTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) WKTNode */
  try {
/*@egen*/
  <GEOMETRYCOLLECTION> GeometryCollectionText()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

/*
 * <GeometryCollection Text> := EMPTY
 * | ( <Geometry Tagged Text> {, <Geometry Tagged Text> }* )
 */
 void GeometryCollectionText()                             :
 {/*@bgen(jjtree) GeometryCollectionText_Node */
  SimpleNode jjtn000 = new SimpleNode(JJTGEOMETRYCOLLECTIONTEXT_NODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
 {/*@bgen(jjtree) GeometryCollectionText_Node */
        try {
/*@egen*/
 	( <LP> GeometryLiteral() ( <COMMA> GeometryLiteral() )* <RP>)?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/
 }
 
/*
 * <Envelope Tagged Text> ::= ENVELOPE <Envelope Text>
 */
 void EnvelopeTaggedText()                         :
 {/*@bgen(jjtree) EnvelopeTaggedText_Node */
  SimpleNode jjtn000 = new SimpleNode(JJTENVELOPETAGGEDTEXT_NODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
 {/*@bgen(jjtree) EnvelopeTaggedText_Node */
        try {
/*@egen*/
 	jjtn000.token = <ENVELOPE> EnvelopText()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/
 }

/*
 * <Envelope Text> := EMPTY
 * | <left paren>
 *		<WestBoundLongitude><comma>
 *   	<EastBoundLongitude><comma>
 *   	<NorthBoundLatitude><comma>
 *   	<SouthBoundLatitude>
 *	<right paren>
 * <WestBoundLongitude> := numeric literal
 * <EastBoundLongitude> := numeric literal
 * <NorthBoundLatitude> := numeric literal
 * <SouthBoundLatitude> := numeric literal
 */
 void EnvelopText()      :
 {}
 {
 	( <LP> 
 		NumericLiteral() <COMMA>
 		NumericLiteral() <COMMA>
 		NumericLiteral() <COMMA>
 		NumericLiteral() 
 	 <RP> )?
 }

