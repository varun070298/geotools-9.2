/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. /home/luis/Downloads/geotools-9.2_terra/modules/library/cql/target/generated-sources/jjtree-javacc/org/geotools/filter/text/generated/parsers/CQLGrammar.jj */
/*@egen*//*
 *    GeoTools - The Open Source Java GIS Tookit
 *    http://geotools.org
 *
 *    (C) 2002-2008, Open Source Geospatial Foundation (OSGeo)
 *
 *    This library is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU Lesser General Public
 *    License as published by the Free Software Foundation;
 *    version 2.1 of the License.
 *
 *    This library is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *    Lesser General Public License for more details.
 */

options {
   STATIC=false;                                                                                                                                                                                                                                                                                                                                                                  

   SANITY_CHECK=true;                  

	// unicode	
   UNICODE_INPUT = true;
   JAVA_UNICODE_ESCAPE = true;
   
   	// debug
   DEBUG_TOKEN_MANAGER=false;
   DEBUG_PARSER=false;
}

PARSER_BEGIN(CQLParser)

package org.geotools.filter.text.generated.parsers;
        
import java.util.HashSet;
import java.util.Set;
import java.util.logging.Logger;




/**
 * CQLParser is the result of a javacc jjtree grammar.
 * 
 * @author  Ian Schneider
 * @author  Mauricio Pazos - Axios Engineering
 * @since 2.5
 * @version $Id: CQLGrammar.jjt 24966 2007-03-30 11:33:47Z vmpazos $
 */
public class CQLParser/*@bgen(jjtree)*/implements CQLParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTCQLParserState jjtree = new JJTCQLParserState();

/*@egen*/

  private final static Logger LOGGER = Logger.getLogger(CQLParser.class.getName());
   
  public void jjtreeOpenNodeScope(Node n) throws ParseException {
 
  }

  public void jjtreeCloseNodeScope(Node n) throws ParseException {

  }

  /**
   * initialize geooperations
   */  
  protected static final Set GEOOP = new HashSet();
  static {
		GEOOP.add("EQUALS");	
		GEOOP.add("DISJOINT");
		GEOOP.add("INTERSECTS");
		GEOOP.add("TOUCHES");
		GEOOP.add("CROSSES");
		GEOOP.add("WITHIN");
		GEOOP.add("CONTAINS");
		GEOOP.add("OVERLAPS");
		GEOOP.add("RELATE");
		GEOOP.add("BBOX");
  }
  
  protected boolean isGeoOp() {
  
  		String tokenImage = getToken(1).image.toUpperCase();
  		boolean OK = 
        			 "(".equals(getToken(2).image)
            		&& GEOOP.contains(tokenImage);
        return OK;
  }
  
  protected static final Set RELGEOOP = new HashSet();
  static {
  	RELGEOOP.add("DWITHIN");
  	RELGEOOP.add("BEYOND"); 
  	
  }
  protected boolean isRelGeoOp() {
  
        return "(".equals(getToken(2).image)
            && RELGEOOP.contains(getToken(1).image.toUpperCase());
  }
  
  protected void logDeprecatedWarning(String op ){
   
  	 boolean deprecated = true;
  	 String shouldUse = "";
  	 if("!".equals(op)){
  	 	shouldUse = "not";
  	 } else if( ("eq".equals(op)) || ("==".equals(op)) ){
  	 	shouldUse= "=";
  	 } else if("neq".equals(op)){
  	 	shouldUse= "<>";
  	 } else if("gt".equals(op)){
  	 	shouldUse= ">";
  	 } else if("lt".equals(op)){
  	 	shouldUse= "<";
  	 } else if("gte".equals(op)){
  	 	shouldUse= ">=";
  	 } else if("lte".equals(op)){
  	 	shouldUse= "<=";
	 } else {
  		 deprecated = false;
	 }
	 if(deprecated){
		LOGGER.warning("\"" + op +"\" is deprecated comparison operator. You should use \"" + shouldUse + "\"");
	}
  }
  
}

PARSER_END(CQLParser)


SKIP : /* WHITE SPACE */
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}


/*
 * <character string literal>
 */
 
TOKEN:
{
    < STRING_LITERAL: "'" ( "''" | ~["'"] )* "'" > : DEFAULT
}
TOKEN [IGNORE_CASE]:
{
    < #DIMENSION_SYMBOL: "*"| "T" | "F" | "0" | "1" | "2"> |
    < DE9IM_PATTERN: <DIMENSION_SYMBOL><DIMENSION_SYMBOL><DIMENSION_SYMBOL><DIMENSION_SYMBOL><DIMENSION_SYMBOL><DIMENSION_SYMBOL><DIMENSION_SYMBOL><DIMENSION_SYMBOL><DIMENSION_SYMBOL> >
}

/*
 * keywords
 */
TOKEN [IGNORE_CASE]:  /* keywords */
{
   < AND: "and" | "&&"> |
   < OR: "or"> |
   < NOT: "not" | "!"> |
   < EQ: "eq" | "==" | "="> |
   < NEQ: "neq" | "<>" > |
   < GT: "gt" | ">" > |
   < LT: "lt" | "<" > |
   < GTE: "gte" | ">="> |
   < LTE: "lte" | "<="> |
   < TRUE: "true"> |
   < FALSE: "false"> |
   < UNKNOWN: "unknown"> |
   < LIKE: "like" > |
   < BETWEEN: "between"> |
   < IS: "is" > |
   < NULL: "null" > 
}

TOKEN [IGNORE_CASE]: /* include all and exclude all filters */
{
  < INCLUDE: "include"> |
  < EXCLUDE: "exclude">
}
  
TOKEN [IGNORE_CASE]: /* geometry markers */
{
  < POINT: "point"> |
  < LINESTRING: "linestring"> |
  < POLYGON: "polygon"> |
  < MULTIPOINT: "multipoint"> |
  < MULTILINESTRING: "multilinestring"> |
  < MULTIPOLYGON: "multipolygon"> |
  < GEOMETRYCOLLECTION: "geometrycollection"> |
  < ENVELOPE: "envelope">
}

TOKEN [IGNORE_CASE]: /* temporal expression*/
{
	<TEQUALS: "tequals">  |
	<BEFORE: "before"> 	| 
	<DURING: "during"> 	|
	<AFTER:  "after">  	|
	<UTC: "T">			
}
TOKEN [IGNORE_CASE]: /* existence predicate*/
{
	<EXISTS: "exists"> |
	<DOES_NOT_EXIST: "does-not-exist">
}

TOKEN [IGNORE_CASE]:  
{
  < EQUALS: "equals" > |
  < DISJOINT: "disjoint"> |
  <INTERSECTS: "intersects" > |
  < TOUCHES: "touches"> |
  < CROSSES: "crosses"> |
  < WITHIN: "within"> |
  < CONTAINS: "contains"> |
  < OVERLAPS: "overlaps"> |
  < RELATE: "relate"> |
  < BBOX: "bbox"> 
}

TOKEN [IGNORE_CASE]: /* relgeoop name */
{
  < DWITHIN: "dwithin"> |
  < BEYOND: "beyond"> 
}

TOKEN [IGNORE_CASE]:
{
	<FEET: "feet" > | 
	<METERS: "meters"> | 
	<STATUTE_MILES: "statute miles"> | 
	<NAUTICAL_MILES: "nautical miles"> | 
	<KILOMETERS: "kilometers">
}


TOKEN:
{
  < LP: "("> |
  < RP: ")"> |
  < LSP: "["> |
  < RSP: "]"> |
  < COMMA: ","> |
  < SENTENCE_SEPARATOR: ";"> |
  < PERIOD: "."> |
  < SLASH: "/"> |
  < COLON: ":">	|
  < MULT: "*"> |
  < PLUS: "+"> |
  < MINUS: "-" > |
  < DOUBLE_QUOTE: "\"">  
}


// Note, because float and int can technically have the same grammar,
// put int first to make token manager have preference for it...
// The same case occurs between identifier and duration tokens, 
// then DURATION has preference over IDENTIFIER
TOKEN [IGNORE_CASE]: /* Literals */
{
  	< INTEGER_LITERAL: ("-")? (<DIGIT>)+ > |
  	< FLOATING_LITERAL:
    	("-")?
    	( ( <DIGIT> )* "." ( <DIGIT> )+ (<EXPONENT>)? ) |
    	( ( <DIGIT> )+ ("." ( <DIGIT> )*)? (<EXPONENT>)? )
  	> |

	< #DUR_DAY:	  (<DIGIT>)+ "D" > |
	< #DUR_MONTH: (<DIGIT>)+ "M" (<DUR_DAY>)? > |
	< #DUR_YEAR:  (<DIGIT>)+ "Y" (<DUR_MONTH>)? > |	
	< #DUR_DATE:  (<DUR_DAY> | <DUR_MONTH> | <DUR_YEAR>) ("T" <DUR_TIME>)?> | 

	< #DUR_HOUR:  (<DIGIT>)+ "H" (<DUR_MINUTE>)?> |
	< #DUR_MINUTE:(<DIGIT>)+ "M" (<DUR_SECOND>)? > |
	< #DUR_SECOND:(<DIGIT>)+ "S" > |	
	< #DUR_TIME:  (<DUR_HOUR> | <DUR_MINUTE> | <DUR_SECOND>) > | 
	
	< DURATION:  ("P" <DUR_DATE> |  "T" <DUR_TIME>) > |
	
	< #FULL_DATE: <DIGIT><DIGIT><DIGIT><DIGIT> "-" <DIGIT><DIGIT> "-" <DIGIT><DIGIT> > |
    < #TIME_ZONE: ("Z") | (("+"|"-") <DIGIT><DIGIT> (":")? <DIGIT><DIGIT>) > |	
	< #UTC_TIME: <DIGIT><DIGIT> ":" <DIGIT><DIGIT> ":" <DIGIT><DIGIT> ("." (<DIGIT>)+)? (<TIME_ZONE>)? > |
	< DATE_TIME : <FULL_DATE>"T"<UTC_TIME> > |

    < IDENTIFIER: (<LETTER> (<LETTER>|<DIGIT>)*) | <DOUBLE_QUOTE> (<ANY>)+ <DOUBLE_QUOTE> > |
    < #ANY: ~[" "] > |    
    
  	< LETTER: [ "a"-"z", "A"-"Z" , "_"] > |
  	< DIGIT: [ "0"-"9"] > |
  	< #EXPONENT: ["e","E"] (["+","-"])? (<DIGIT>)+ > 
}


/*
 * Program structuring syntax to parse a single filter.
 */
Node FilterCompilationUnit() :
{}
{
   SearchCondition()
   <EOF>
   {return jjtree.rootNode();}
}

/*
 * Program structuring syntax to parse a single expression.
 */
Node ExpressionCompilationUnit() :
{}
{
   Expression()
   <EOF>
   {return jjtree.rootNode();}
}

/*
 * Program structuring syntax to parse a list of filters.
 */
Node FilterListCompilationUnit() :
{}
{
   SequenceOfSearchConditions()
   <EOF>
   {return jjtree.rootNode();}
}

void SearchCondition()      :
{}
{
	 BooleanValueExpression()
}
/*
 * <SequenceOfSearchConditions> ::= 
 * 			<search condition>
 * 		|	<SequenceOfSearchConditions> ; <search condition>
 */ 
void SequenceOfSearchConditions()      :
{}
{
		SearchCondition() (<SENTENCE_SEPARATOR> SearchCondition())*
}

/*
 * <boolean value expression> ::= 
 *			<boolean term>
 * 		| 	<boolean value expression> OR <boolean term>
 */
void BooleanValueExpression()      :
{}
{
		BooleanTerm()( <OR>/*@bgen(jjtree) Boolean_Or_Node */
                                    {
                                      SimpleNode jjtn001 = new SimpleNode(JJTBOOLEAN_OR_NODE);
                                      boolean jjtc001 = true;
                                      jjtree.openNodeScope(jjtn001);
                                      jjtreeOpenNodeScope(jjtn001);
                                    }
                                    try {
/*@egen*/ BooleanTerm()/*@bgen(jjtree)*/
                                    } catch (Throwable jjte001) {
                                      if (jjtc001) {
                                        jjtree.clearNodeScope(jjtn001);
                                        jjtc001 = false;
                                      } else {
                                        jjtree.popNode();
                                      }
                                      if (jjte001 instanceof RuntimeException) {
                                        throw (RuntimeException)jjte001;
                                      }
                                      if (jjte001 instanceof ParseException) {
                                        throw (ParseException)jjte001;
                                      }
                                      throw (Error)jjte001;
                                    } finally {
                                      if (jjtc001) {
                                        jjtree.closeNodeScope(jjtn001, true);
                                        jjtreeCloseNodeScope(jjtn001);
                                      }
                                    }
/*@egen*/ )*
}


/*
 * <boolean term> ::= 
 *            <boolean factor>
 *          | <boolean term> AND <boolean factor>
 */
void BooleanTerm()       :
{}
{
	 BooleanFactor()( <AND>/*@bgen(jjtree) Boolean_And_Node */
                                {
                                  SimpleNode jjtn001 = new SimpleNode(JJTBOOLEAN_AND_NODE);
                                  boolean jjtc001 = true;
                                  jjtree.openNodeScope(jjtn001);
                                  jjtreeOpenNodeScope(jjtn001);
                                }
                                try {
/*@egen*/ BooleanFactor()/*@bgen(jjtree)*/
                                } catch (Throwable jjte001) {
                                  if (jjtc001) {
                                    jjtree.clearNodeScope(jjtn001);
                                    jjtc001 = false;
                                  } else {
                                    jjtree.popNode();
                                  }
                                  if (jjte001 instanceof RuntimeException) {
                                    throw (RuntimeException)jjte001;
                                  }
                                  if (jjte001 instanceof ParseException) {
                                    throw (ParseException)jjte001;
                                  }
                                  throw (Error)jjte001;
                                } finally {
                                  if (jjtc001) {
                                    jjtree.closeNodeScope(jjtn001, true);
                                    jjtreeCloseNodeScope(jjtn001);
                                  }
                                }
/*@egen*/ )*
}


void BooleanFactor()      :
{}
{
	 	<NOT> {logDeprecatedWarning(getToken(0).image);}/*@bgen(jjtree) Boolean_Not_Node */
                                                                 {
                                                                   SimpleNode jjtn001 = new SimpleNode(JJTBOOLEAN_NOT_NODE);
                                                                   boolean jjtc001 = true;
                                                                   jjtree.openNodeScope(jjtn001);
                                                                   jjtreeOpenNodeScope(jjtn001);
                                                                 }
                                                                 try {
/*@egen*/ BooleanPrimary()/*@bgen(jjtree)*/
                                                                 } catch (Throwable jjte001) {
                                                                   if (jjtc001) {
                                                                     jjtree.clearNodeScope(jjtn001);
                                                                     jjtc001 = false;
                                                                   } else {
                                                                     jjtree.popNode();
                                                                   }
                                                                   if (jjte001 instanceof RuntimeException) {
                                                                     throw (RuntimeException)jjte001;
                                                                   }
                                                                   if (jjte001 instanceof ParseException) {
                                                                     throw (ParseException)jjte001;
                                                                   }
                                                                   throw (Error)jjte001;
                                                                 } finally {
                                                                   if (jjtc001) {
                                                                     jjtree.closeNodeScope(jjtn001, true);
                                                                     jjtreeCloseNodeScope(jjtn001);
                                                                   }
                                                                 }
/*@egen*/
	|	BooleanPrimary()
}

void BooleanPrimary()      :
{}
{
		LOOKAHEAD(Predicate()) Predicate() 
	|	IncludeExcludePredicate() 
	|  	<LP>SearchCondition()<RP> 
	|  	<LSP>SearchCondition()<RSP>
	| 	RoutineInvocation() 
}

/*
 * <predicate> ::= <comparison predicate>
 * 	| <text predicate>
 * 	| <null predicate>
 * 	| <temporal predicate>
 * 	| <classification predicate> (*not supported*)
 * 	| <existence predicate> 
 * 	| <between predicate> (*extension*)
 *  | <includeexclude predicate> (*extension*)
 */
void Predicate()      :
{}
{
	Attribute() 
	(
			LOOKAHEAD(3)TextPredicate()
		|  	LOOKAHEAD(3)NullPredicate() 
		| 	LOOKAHEAD(3)ExistencePredicate() 
		| 	LOOKAHEAD(3)TemporalPredicate() 
		|   LOOKAHEAD(3)BetweenPredicate()		
		|	 {logDeprecatedWarning(getToken(1).image);} ComparisonPredicate()
	)
}

/* ---------------------------------------- *
 *   	<routine invocation>
 * ---------------------------------------- *
/*
 * <routine invocation> ::= 
 *	 <geoop name><georoutine argument list>
 * | <relgeoop name><relgeoop argument list>
 * | <routine name><argument list>
 */
void RoutineInvocation()      :
{}
{
		LOOKAHEAD({ isGeoOp() })   		RoutineInvocationGeoOp()
	|	LOOKAHEAD({ isRelGeoOp() })		RoutineInvocationRelGeoOp()
	|	RoutineInvocationGeneric()
}

void RoutineInvocationGeoOp()      :
{}
{
  	<EQUALS>/*@bgen(jjtree) RoutineInvocation_GeoOp_Equal_Node */
                        {
                          SimpleNode jjtn001 = new SimpleNode(JJTROUTINEINVOCATION_GEOOP_EQUAL_NODE);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                          jjtreeOpenNodeScope(jjtn001);
                        }
                        try {
/*@egen*/ 	GeoRoutineArgumentList()/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001, true);
                            jjtreeCloseNodeScope(jjtn001);
                          }
                        }
/*@egen*/
  |	<DISJOINT>/*@bgen(jjtree) RoutineInvocation_GeoOp_Disjoint_Node */
                        {
                          SimpleNode jjtn002 = new SimpleNode(JJTROUTINEINVOCATION_GEOOP_DISJOINT_NODE);
                          boolean jjtc002 = true;
                          jjtree.openNodeScope(jjtn002);
                          jjtreeOpenNodeScope(jjtn002);
                        }
                        try {
/*@egen*/ 	GeoRoutineArgumentList()/*@bgen(jjtree)*/
                        } catch (Throwable jjte002) {
                          if (jjtc002) {
                            jjtree.clearNodeScope(jjtn002);
                            jjtc002 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte002 instanceof RuntimeException) {
                            throw (RuntimeException)jjte002;
                          }
                          if (jjte002 instanceof ParseException) {
                            throw (ParseException)jjte002;
                          }
                          throw (Error)jjte002;
                        } finally {
                          if (jjtc002) {
                            jjtree.closeNodeScope(jjtn002, true);
                            jjtreeCloseNodeScope(jjtn002);
                          }
                        }
/*@egen*/
  |	<INTERSECTS>/*@bgen(jjtree) RoutineInvocation_GeoOp_Intersect_Node */
                     {
                       SimpleNode jjtn003 = new SimpleNode(JJTROUTINEINVOCATION_GEOOP_INTERSECT_NODE);
                       boolean jjtc003 = true;
                       jjtree.openNodeScope(jjtn003);
                       jjtreeOpenNodeScope(jjtn003);
                     }
                     try {
/*@egen*/ GeoRoutineArgumentList()/*@bgen(jjtree)*/
                     } catch (Throwable jjte003) {
                       if (jjtc003) {
                         jjtree.clearNodeScope(jjtn003);
                         jjtc003 = false;
                       } else {
                         jjtree.popNode();
                       }
                       if (jjte003 instanceof RuntimeException) {
                         throw (RuntimeException)jjte003;
                       }
                       if (jjte003 instanceof ParseException) {
                         throw (ParseException)jjte003;
                       }
                       throw (Error)jjte003;
                     } finally {
                       if (jjtc003) {
                         jjtree.closeNodeScope(jjtn003, true);
                         jjtreeCloseNodeScope(jjtn003);
                       }
                     }
/*@egen*/
  |	<TOUCHES>/*@bgen(jjtree) RoutineInvocation_GeoOp_Touch_Node */
                        {
                          SimpleNode jjtn004 = new SimpleNode(JJTROUTINEINVOCATION_GEOOP_TOUCH_NODE);
                          boolean jjtc004 = true;
                          jjtree.openNodeScope(jjtn004);
                          jjtreeOpenNodeScope(jjtn004);
                        }
                        try {
/*@egen*/ 	GeoRoutineArgumentList()/*@bgen(jjtree)*/
                        } catch (Throwable jjte004) {
                          if (jjtc004) {
                            jjtree.clearNodeScope(jjtn004);
                            jjtc004 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte004 instanceof RuntimeException) {
                            throw (RuntimeException)jjte004;
                          }
                          if (jjte004 instanceof ParseException) {
                            throw (ParseException)jjte004;
                          }
                          throw (Error)jjte004;
                        } finally {
                          if (jjtc004) {
                            jjtree.closeNodeScope(jjtn004, true);
                            jjtreeCloseNodeScope(jjtn004);
                          }
                        }
/*@egen*/
  |	<CROSSES>/*@bgen(jjtree) RoutineInvocation_GeoOp_Cross_Node */
                        {
                          SimpleNode jjtn005 = new SimpleNode(JJTROUTINEINVOCATION_GEOOP_CROSS_NODE);
                          boolean jjtc005 = true;
                          jjtree.openNodeScope(jjtn005);
                          jjtreeOpenNodeScope(jjtn005);
                        }
                        try {
/*@egen*/ 	GeoRoutineArgumentList()/*@bgen(jjtree)*/
                        } catch (Throwable jjte005) {
                          if (jjtc005) {
                            jjtree.clearNodeScope(jjtn005);
                            jjtc005 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte005 instanceof RuntimeException) {
                            throw (RuntimeException)jjte005;
                          }
                          if (jjte005 instanceof ParseException) {
                            throw (ParseException)jjte005;
                          }
                          throw (Error)jjte005;
                        } finally {
                          if (jjtc005) {
                            jjtree.closeNodeScope(jjtn005, true);
                            jjtreeCloseNodeScope(jjtn005);
                          }
                        }
/*@egen*/
  |	<WITHIN>/*@bgen(jjtree) RoutineInvocation_GeoOp_Within_Node */
                        {
                          SimpleNode jjtn006 = new SimpleNode(JJTROUTINEINVOCATION_GEOOP_WITHIN_NODE);
                          boolean jjtc006 = true;
                          jjtree.openNodeScope(jjtn006);
                          jjtreeOpenNodeScope(jjtn006);
                        }
                        try {
/*@egen*/ 	GeoRoutineArgumentList()/*@bgen(jjtree)*/
                        } catch (Throwable jjte006) {
                          if (jjtc006) {
                            jjtree.clearNodeScope(jjtn006);
                            jjtc006 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte006 instanceof RuntimeException) {
                            throw (RuntimeException)jjte006;
                          }
                          if (jjte006 instanceof ParseException) {
                            throw (ParseException)jjte006;
                          }
                          throw (Error)jjte006;
                        } finally {
                          if (jjtc006) {
                            jjtree.closeNodeScope(jjtn006, true);
                            jjtreeCloseNodeScope(jjtn006);
                          }
                        }
/*@egen*/
  |	<CONTAINS>/*@bgen(jjtree) RoutineInvocation_GeoOp_Contain_Node */
                        {
                          SimpleNode jjtn007 = new SimpleNode(JJTROUTINEINVOCATION_GEOOP_CONTAIN_NODE);
                          boolean jjtc007 = true;
                          jjtree.openNodeScope(jjtn007);
                          jjtreeOpenNodeScope(jjtn007);
                        }
                        try {
/*@egen*/ 	GeoRoutineArgumentList()/*@bgen(jjtree)*/
                        } catch (Throwable jjte007) {
                          if (jjtc007) {
                            jjtree.clearNodeScope(jjtn007);
                            jjtc007 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte007 instanceof RuntimeException) {
                            throw (RuntimeException)jjte007;
                          }
                          if (jjte007 instanceof ParseException) {
                            throw (ParseException)jjte007;
                          }
                          throw (Error)jjte007;
                        } finally {
                          if (jjtc007) {
                            jjtree.closeNodeScope(jjtn007, true);
                            jjtreeCloseNodeScope(jjtn007);
                          }
                        }
/*@egen*/
  |	<OVERLAPS>/*@bgen(jjtree) RoutineInvocation_GeoOp_Overlap_Node */
                        {
                          SimpleNode jjtn008 = new SimpleNode(JJTROUTINEINVOCATION_GEOOP_OVERLAP_NODE);
                          boolean jjtc008 = true;
                          jjtree.openNodeScope(jjtn008);
                          jjtreeOpenNodeScope(jjtn008);
                        }
                        try {
/*@egen*/ 	GeoRoutineArgumentList()/*@bgen(jjtree)*/
                        } catch (Throwable jjte008) {
                          if (jjtc008) {
                            jjtree.clearNodeScope(jjtn008);
                            jjtc008 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte008 instanceof RuntimeException) {
                            throw (RuntimeException)jjte008;
                          }
                          if (jjte008 instanceof ParseException) {
                            throw (ParseException)jjte008;
                          }
                          throw (Error)jjte008;
                        } finally {
                          if (jjtc008) {
                            jjtree.closeNodeScope(jjtn008, true);
                            jjtreeCloseNodeScope(jjtn008);
                          }
                        }
/*@egen*/
  |	<RELATE>/*@bgen(jjtree) RoutineInvocation_GeoOp_Relate_Node */
                        {
                          SimpleNode jjtn009 = new SimpleNode(JJTROUTINEINVOCATION_GEOOP_RELATE_NODE);
                          boolean jjtc009 = true;
                          jjtree.openNodeScope(jjtn009);
                          jjtreeOpenNodeScope(jjtn009);
                        }
                        try {
/*@egen*/ 	RelateArgumentList()/*@bgen(jjtree)*/
                        } catch (Throwable jjte009) {
                          if (jjtc009) {
                            jjtree.clearNodeScope(jjtn009);
                            jjtc009 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte009 instanceof RuntimeException) {
                            throw (RuntimeException)jjte009;
                          }
                          if (jjte009 instanceof ParseException) {
                            throw (ParseException)jjte009;
                          }
                          throw (Error)jjte009;
                        } finally {
                          if (jjtc009) {
                            jjtree.closeNodeScope(jjtn009, true);
                            jjtreeCloseNodeScope(jjtn009);
                          }
                        }
/*@egen*/
  | <BBOX> 		BBoxArgumentList()		 
}

/*
 * <georoutine argument list> ::=
 *		<left paren><attribute name><comma><geometry literal><right paren>
 *
 */
void GeoRoutineArgumentList()      :
{}
{
	<LP> Attribute() <COMMA> GeometryLiteral() <RP>
}
void RelateArgumentList()      :
{}
{
    <LP> Attribute() <COMMA> GeometryLiteral() <COMMA> DE9IM() <RP>
}

void DE9IM()            :
{/*@bgen(jjtree) DE9IM_Node */
  SimpleNode jjtn000 = new SimpleNode(JJTDE9IM_NODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DE9IM_Node */
    try {
/*@egen*/
    <DE9IM_PATTERN>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

/*
 * <bbox argument list>::= 
 * 	"(" <attribute> "," 
 * 		<min X> ","
 * 		<min Y> ","
 * 		<max X> ","
 * 		<max Y> 
 * 		[, srs] ")"
 * 
 * <min X> ::= <signed numerical literal> 
 * <min Y> ::= <signed numerical literal> 
 * <max X> ::= <signed numerical literal> 
 * <max Y> ::= <signed numerical literal> 
 * <srs> ::= <character string literal>
*/
void BBoxArgumentList()      :
{}
{
		<LP> Attribute() <COMMA> 
			 SignedNumericLiteral() <COMMA>
			 SignedNumericLiteral() <COMMA>
			 SignedNumericLiteral() <COMMA>
			 SignedNumericLiteral() 
			 (/*@bgen(jjtree) RoutineInvocation_GeoOp_BBOX_Node */
                           {
                             SimpleNode jjtn001 = new SimpleNode(JJTROUTINEINVOCATION_GEOOP_BBOX_NODE);
                             boolean jjtc001 = true;
                             jjtree.openNodeScope(jjtn001);
                             jjtreeOpenNodeScope(jjtn001);
                           }
                           try {
/*@egen*/ <RP>/*@bgen(jjtree)*/
                           } finally {
                             if (jjtc001) {
                               jjtree.closeNodeScope(jjtn001, true);
                               jjtreeCloseNodeScope(jjtn001);
                             }
                           }
/*@egen*/
			  | <COMMA> StringLiteral()/*@bgen(jjtree) RoutineInvocation_GeoOp_BBOX_SRS_Node */
                                                   {
                                                     SimpleNode jjtn002 = new SimpleNode(JJTROUTINEINVOCATION_GEOOP_BBOX_SRS_NODE);
                                                     boolean jjtc002 = true;
                                                     jjtree.openNodeScope(jjtn002);
                                                     jjtreeOpenNodeScope(jjtn002);
                                                   }
                                                   try {
/*@egen*/<RP>/*@bgen(jjtree)*/
                                                   } finally {
                                                     if (jjtc002) {
                                                       jjtree.closeNodeScope(jjtn002, true);
                                                       jjtreeCloseNodeScope(jjtn002);
                                                     }
                                                   }
/*@egen*/)
			
		
}

/*
 * <relgeoop name> ::= DWITHIN | BEYOND
 */
void RoutineInvocationRelGeoOp()      :
{}
{
  	<DWITHIN>/*@bgen(jjtree) RoutineInvocation_RelOp_DWITHIN_Node */
                        {
                          SimpleNode jjtn001 = new SimpleNode(JJTROUTINEINVOCATION_RELOP_DWITHIN_NODE);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                          jjtreeOpenNodeScope(jjtn001);
                        }
                        try {
/*@egen*/ 	RelGeoRoutineArgumentList()/*@bgen(jjtree)*/
                        } catch (Throwable jjte001) {
                          if (jjtc001) {
                            jjtree.clearNodeScope(jjtn001);
                            jjtc001 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte001 instanceof RuntimeException) {
                            throw (RuntimeException)jjte001;
                          }
                          if (jjte001 instanceof ParseException) {
                            throw (ParseException)jjte001;
                          }
                          throw (Error)jjte001;
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001, true);
                            jjtreeCloseNodeScope(jjtn001);
                          }
                        }
/*@egen*/
  |	<BEYOND>/*@bgen(jjtree) RoutineInvocation_RelOp_BEYOND_Node */
                        {
                          SimpleNode jjtn002 = new SimpleNode(JJTROUTINEINVOCATION_RELOP_BEYOND_NODE);
                          boolean jjtc002 = true;
                          jjtree.openNodeScope(jjtn002);
                          jjtreeOpenNodeScope(jjtn002);
                        }
                        try {
/*@egen*/ 	RelGeoRoutineArgumentList()/*@bgen(jjtree)*/
                        } catch (Throwable jjte002) {
                          if (jjtc002) {
                            jjtree.clearNodeScope(jjtn002);
                            jjtc002 = false;
                          } else {
                            jjtree.popNode();
                          }
                          if (jjte002 instanceof RuntimeException) {
                            throw (RuntimeException)jjte002;
                          }
                          if (jjte002 instanceof ParseException) {
                            throw (ParseException)jjte002;
                          }
                          throw (Error)jjte002;
                        } finally {
                          if (jjtc002) {
                            jjtree.closeNodeScope(jjtn002, true);
                            jjtreeCloseNodeScope(jjtn002);
                          }
                        }
/*@egen*/
}

/*
 * <relgeoop argument list> ::= 
 *		<left paren><attribute name><comma><geometry literal><comma><tolerance><right paren>
 */
void RelGeoRoutineArgumentList()      :
{}
{
	<LP> Attribute() <COMMA> GeometryLiteral() <COMMA> Tolerance() <RP>
}
/*
 * <tolerance> ::= <unsigned numeric literal><comma><distance units>
 */
void Tolerance() :
{}
{/*@bgen(jjtree) Tolerance_Node */
        {
          SimpleNode jjtn001 = new SimpleNode(JJTTOLERANCE_NODE);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
          jjtreeOpenNodeScope(jjtn001);
        }
        try {
/*@egen*/
	UnsignedNumericLiteral()/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001, true);
            jjtreeCloseNodeScope(jjtn001);
          }
        }
/*@egen*/ <COMMA> DistanceUnits()
}

void UnsignedNumericLiteral():
{}
{
	SignedNumericLiteral() // TODO must be redefined for number token to handle sign correctly
}

/**
 * <distance units> ::=
 *	 'feet' | 'meters' | 'statute miles' |
 *   'nautical miles' | 'kilometers'
 * 
 * TODO this set of units is just an example. The real list of distance unit must be developed
 */ 
void DistanceUnits()                    :
{/*@bgen(jjtree) DistanceUnits_Node */
  SimpleNode jjtn000 = new SimpleNode(JJTDISTANCEUNITS_NODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DistanceUnits_Node */
        try {
/*@egen*/
	<FEET> | <METERS> | <STATUTE_MILES> | <NAUTICAL_MILES> | <KILOMETERS>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/
}


/*
 * <geometry literal> ::= 
 *	  <Point Tagged Text>
 * 	| <LineString Tagged Text>
 * 	| <Polygon Tagged Text>
 *	| <MultiPoint Tagged Text>
 *  | <MultiLineString Tagged Text>
 * 	| <MultiPolygon Tagged Text>
 * 	| <GeometryCollection Tagged Text>
 *	| <Envelope Tagged Text>
 */
void GeometryLiteral()      :
{}
{
  PointTaggedText() |
  LineStringTaggedText() |
  PolygonTaggedText() |
  MultiPointTaggedText() |
  MultiLineStringTaggedText() |
  MultiPolygonTaggedText() |
  GeometryCollectionTaggedText() |
  EnvelopeTaggedText()
}
/*
 *  <routine invocation > ::= 
 *  |   <routine name > <argument list > 
 *                                           
 * <argument list&gt ::=    
 *      <left paren> [<positional arguments>] <right paren>
 * <positional arguments> ::=
 *      <argument> [ { <comma&gt <argument> }... ]
 *           
 * <argument>  ::= 
 *      <literal>  
 *  |   <attribute name>                                            
 *  |   <function>           (*Extension*)                                            
 *  |   <binary expression>  (*Extnsion*)                            
 */
void RoutineInvocationGeneric()      :
{}
{
	Function()
}

/* ---------------------------------------- *
 *   	End <routine invocation>
 * ---------------------------------------- *


/* ---------------------------------------- *
 *   	<includeexclude predicate>
 * ---------------------------------------- *
/*
 * <includeexclude predicate> ::= 
 *		  <INCLUDE> | <EXCLUDE>
 */
void IncludeExcludePredicate()      :
{}
{/*@bgen(jjtree) Include_Node */
   {
     SimpleNode jjtn001 = new SimpleNode(JJTINCLUDE_NODE);
     boolean jjtc001 = true;
     jjtree.openNodeScope(jjtn001);
     jjtreeOpenNodeScope(jjtn001);
   }
   try {
/*@egen*/
   <INCLUDE>/*@bgen(jjtree)*/
   } finally {
     if (jjtc001) {
       jjtree.closeNodeScope(jjtn001, true);
       jjtreeCloseNodeScope(jjtn001);
     }
   }
/*@egen*/
   |/*@bgen(jjtree) Exclude_Node */
     {
       SimpleNode jjtn002 = new SimpleNode(JJTEXCLUDE_NODE);
       boolean jjtc002 = true;
       jjtree.openNodeScope(jjtn002);
       jjtreeOpenNodeScope(jjtn002);
     }
     try {
/*@egen*/ <EXCLUDE>/*@bgen(jjtree)*/
     } finally {
       if (jjtc002) {
         jjtree.closeNodeScope(jjtn002, true);
         jjtreeCloseNodeScope(jjtn002);
       }
     }
/*@egen*/
}

/* ---------------------------------------- *
 *   	<comparison predicate>
 * ---------------------------------------- *
/*
 * <comparison predicate> ::= 
 *		  <attribute name> <comp op> <literal>
 */
void ComparisonPredicate() :
{}
{
   	 <EQ>/*@bgen(jjtree) COMPARISONPREDICATE_EQ_Node */
               {
                 SimpleNode jjtn001 = new SimpleNode(JJTCOMPARISONPREDICATE_EQ_NODE);
                 boolean jjtc001 = true;
                 jjtree.openNodeScope(jjtn001);
                 jjtreeOpenNodeScope(jjtn001);
               }
               try {
/*@egen*/  Expression()/*@bgen(jjtree)*/
               } catch (Throwable jjte001) {
                 if (jjtc001) {
                   jjtree.clearNodeScope(jjtn001);
                   jjtc001 = false;
                 } else {
                   jjtree.popNode();
                 }
                 if (jjte001 instanceof RuntimeException) {
                   throw (RuntimeException)jjte001;
                 }
                 if (jjte001 instanceof ParseException) {
                   throw (ParseException)jjte001;
                 }
                 throw (Error)jjte001;
               } finally {
                 if (jjtc001) {
                   jjtree.closeNodeScope(jjtn001, true);
                   jjtreeCloseNodeScope(jjtn001);
                 }
               }
/*@egen*/ 
   | <GT>/*@bgen(jjtree) COMPARISONPREDICATE_GT_Node */
           {
             SimpleNode jjtn002 = new SimpleNode(JJTCOMPARISONPREDICATE_GT_NODE);
             boolean jjtc002 = true;
             jjtree.openNodeScope(jjtn002);
             jjtreeOpenNodeScope(jjtn002);
           }
           try {
/*@egen*/  Expression()/*@bgen(jjtree)*/
           } catch (Throwable jjte002) {
             if (jjtc002) {
               jjtree.clearNodeScope(jjtn002);
               jjtc002 = false;
             } else {
               jjtree.popNode();
             }
             if (jjte002 instanceof RuntimeException) {
               throw (RuntimeException)jjte002;
             }
             if (jjte002 instanceof ParseException) {
               throw (ParseException)jjte002;
             }
             throw (Error)jjte002;
           } finally {
             if (jjtc002) {
               jjtree.closeNodeScope(jjtn002, true);
               jjtreeCloseNodeScope(jjtn002);
             }
           }
/*@egen*/
   | <LT>/*@bgen(jjtree) COMPARISONPREDICATE_LT_Node */
           {
             SimpleNode jjtn003 = new SimpleNode(JJTCOMPARISONPREDICATE_LT_NODE);
             boolean jjtc003 = true;
             jjtree.openNodeScope(jjtn003);
             jjtreeOpenNodeScope(jjtn003);
           }
           try {
/*@egen*/  Expression()/*@bgen(jjtree)*/
           } catch (Throwable jjte003) {
             if (jjtc003) {
               jjtree.clearNodeScope(jjtn003);
               jjtc003 = false;
             } else {
               jjtree.popNode();
             }
             if (jjte003 instanceof RuntimeException) {
               throw (RuntimeException)jjte003;
             }
             if (jjte003 instanceof ParseException) {
               throw (ParseException)jjte003;
             }
             throw (Error)jjte003;
           } finally {
             if (jjtc003) {
               jjtree.closeNodeScope(jjtn003, true);
               jjtreeCloseNodeScope(jjtn003);
             }
           }
/*@egen*/
   | <GTE>/*@bgen(jjtree) COMPARISONPREDICATE_GTE_Node */
           {
             SimpleNode jjtn004 = new SimpleNode(JJTCOMPARISONPREDICATE_GTE_NODE);
             boolean jjtc004 = true;
             jjtree.openNodeScope(jjtn004);
             jjtreeOpenNodeScope(jjtn004);
           }
           try {
/*@egen*/ Expression()/*@bgen(jjtree)*/
           } catch (Throwable jjte004) {
             if (jjtc004) {
               jjtree.clearNodeScope(jjtn004);
               jjtc004 = false;
             } else {
               jjtree.popNode();
             }
             if (jjte004 instanceof RuntimeException) {
               throw (RuntimeException)jjte004;
             }
             if (jjte004 instanceof ParseException) {
               throw (ParseException)jjte004;
             }
             throw (Error)jjte004;
           } finally {
             if (jjtc004) {
               jjtree.closeNodeScope(jjtn004, true);
               jjtreeCloseNodeScope(jjtn004);
             }
           }
/*@egen*/
   | <LTE>/*@bgen(jjtree) COMPARISONPREDICATE_LTE_Node */
           {
             SimpleNode jjtn005 = new SimpleNode(JJTCOMPARISONPREDICATE_LTE_NODE);
             boolean jjtc005 = true;
             jjtree.openNodeScope(jjtn005);
             jjtreeOpenNodeScope(jjtn005);
           }
           try {
/*@egen*/ Expression()/*@bgen(jjtree)*/
           } catch (Throwable jjte005) {
             if (jjtc005) {
               jjtree.clearNodeScope(jjtn005);
               jjtc005 = false;
             } else {
               jjtree.popNode();
             }
             if (jjte005 instanceof RuntimeException) {
               throw (RuntimeException)jjte005;
             }
             if (jjte005 instanceof ParseException) {
               throw (ParseException)jjte005;
             }
             throw (Error)jjte005;
           } finally {
             if (jjtc005) {
               jjtree.closeNodeScope(jjtn005, true);
               jjtreeCloseNodeScope(jjtn005);
             }
           }
/*@egen*/
   | <NEQ>/*@bgen(jjtree) COMPARISONPREDICATE_Not_Equal_Node */
           {
             SimpleNode jjtn006 = new SimpleNode(JJTCOMPARISONPREDICATE_NOT_EQUAL_NODE);
             boolean jjtc006 = true;
             jjtree.openNodeScope(jjtn006);
             jjtreeOpenNodeScope(jjtn006);
           }
           try {
/*@egen*/ Expression()/*@bgen(jjtree)*/
           } catch (Throwable jjte006) {
             if (jjtc006) {
               jjtree.clearNodeScope(jjtn006);
               jjtc006 = false;
             } else {
               jjtree.popNode();
             }
             if (jjte006 instanceof RuntimeException) {
               throw (RuntimeException)jjte006;
             }
             if (jjte006 instanceof ParseException) {
               throw (ParseException)jjte006;
             }
             throw (Error)jjte006;
           } finally {
             if (jjtc006) {
               jjtree.closeNodeScope(jjtn006, true);
               jjtreeCloseNodeScope(jjtn006);
             }
           }
/*@egen*/
}

/*
 * <null predicate> ::= <attribute name> IS [ NOT ] NULL 
 */
void NullPredicate() :
{}
{
	  LOOKAHEAD(3) 	<IS>/*@bgen(jjtree) NullPredicateNode */
                             {
                               SimpleNode jjtn001 = new SimpleNode(JJTNULLPREDICATENODE);
                               boolean jjtc001 = true;
                               jjtree.openNodeScope(jjtn001);
                               jjtreeOpenNodeScope(jjtn001);
                             }
                             try {
/*@egen*/ <NULL>/*@bgen(jjtree)*/
                             } finally {
                               if (jjtc001) {
                                 jjtree.closeNodeScope(jjtn001, true);
                                 jjtreeCloseNodeScope(jjtn001);
                               }
                             }
/*@egen*/
	|  				<IS> <NOT>/*@bgen(jjtree) NotNullPredicateNode */
                                                   {
                                                     SimpleNode jjtn002 = new SimpleNode(JJTNOTNULLPREDICATENODE);
                                                     boolean jjtc002 = true;
                                                     jjtree.openNodeScope(jjtn002);
                                                     jjtreeOpenNodeScope(jjtn002);
                                                   }
                                                   try {
/*@egen*/ <NULL>/*@bgen(jjtree)*/
                                                   } finally {
                                                     if (jjtc002) {
                                                       jjtree.closeNodeScope(jjtn002, true);
                                                       jjtreeCloseNodeScope(jjtn002);
                                                     }
                                                   }
/*@egen*/
}


/* ---------------------------------------- *
 *   	<temporal predicate>
 * ---------------------------------------- *
 * <temporal predicate> ::= 
 *	  <attribute_name> TEQUAL <date-time expression>
 *	| <attribute_name> BEFORE <date-time expression>
 *	| <attribute_name> BEFORE OR DURING <period>
 *	| <attribute_name> DURING <period>
 *	| <attribute_name> DURING OR AFTER <period>
 *	| <attribute_name> AFTER <date-time expression>
 */
void TemporalPredicate()      :
{}
{
		<TEQUALS> TemporalPredicateTEquals()  
	|	<BEFORE> TemporalPredicateBefore() 	
	|   <AFTER>	 TemporalPredicateAfter()	
	|	<DURING> TemporalPredicateDuring()	
	
}

void TemporalPredicateTEquals()                        :
{/*@bgen(jjtree) TPTEquals_DateTime_Node */
  SimpleNode jjtn000 = new SimpleNode(JJTTPTEQUALS_DATETIME_NODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TPTEquals_DateTime_Node */
    try {
/*@egen*/
    DateTimeExpression()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/  
}

void TemporalPredicateBefore()     :
{}
{/*@bgen(jjtree) TPBefore_DateTime_Node */
                {
                  SimpleNode jjtn001 = new SimpleNode(JJTTPBEFORE_DATETIME_NODE);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                  jjtreeOpenNodeScope(jjtn001);
                }
                try {
/*@egen*/
		DateTimeExpression()/*@bgen(jjtree)*/
                } catch (Throwable jjte001) {
                  if (jjtc001) {
                    jjtree.clearNodeScope(jjtn001);
                    jjtc001 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte001 instanceof RuntimeException) {
                    throw (RuntimeException)jjte001;
                  }
                  if (jjte001 instanceof ParseException) {
                    throw (ParseException)jjte001;
                  }
                  throw (Error)jjte001;
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001, true);
                    jjtreeCloseNodeScope(jjtn001);
                  }
                }
/*@egen*/
	|	<OR> <DURING>/*@bgen(jjtree) TPBefore_Or_During_Period_Node */
                              {
                                SimpleNode jjtn002 = new SimpleNode(JJTTPBEFORE_OR_DURING_PERIOD_NODE);
                                boolean jjtc002 = true;
                                jjtree.openNodeScope(jjtn002);
                                jjtreeOpenNodeScope(jjtn002);
                              }
                              try {
/*@egen*/ Period()/*@bgen(jjtree)*/
                              } catch (Throwable jjte002) {
                                if (jjtc002) {
                                  jjtree.clearNodeScope(jjtn002);
                                  jjtc002 = false;
                                } else {
                                  jjtree.popNode();
                                }
                                if (jjte002 instanceof RuntimeException) {
                                  throw (RuntimeException)jjte002;
                                }
                                if (jjte002 instanceof ParseException) {
                                  throw (ParseException)jjte002;
                                }
                                throw (Error)jjte002;
                              } finally {
                                if (jjtc002) {
                                  jjtree.closeNodeScope(jjtn002, true);
                                  jjtreeCloseNodeScope(jjtn002);
                                }
                              }
/*@egen*/ 
}

void TemporalPredicateAfter()                       :
{/*@bgen(jjtree) TPAfter_DateTime_Node */
  SimpleNode jjtn000 = new SimpleNode(JJTTPAFTER_DATETIME_NODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) TPAfter_DateTime_Node */
                try {
/*@egen*/
		DateTimeExpression()/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtreeCloseNodeScope(jjtn000);
                  }
                }
/*@egen*/
}

void TemporalPredicateDuring()     :
{}
{/*@bgen(jjtree) TPDuring_Period_Node */
                {
                  SimpleNode jjtn001 = new SimpleNode(JJTTPDURING_PERIOD_NODE);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                  jjtreeOpenNodeScope(jjtn001);
                }
                try {
/*@egen*/
		Period()/*@bgen(jjtree)*/
                } catch (Throwable jjte001) {
                  if (jjtc001) {
                    jjtree.clearNodeScope(jjtn001);
                    jjtc001 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte001 instanceof RuntimeException) {
                    throw (RuntimeException)jjte001;
                  }
                  if (jjte001 instanceof ParseException) {
                    throw (ParseException)jjte001;
                  }
                  throw (Error)jjte001;
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001, true);
                    jjtreeCloseNodeScope(jjtn001);
                  }
                }
/*@egen*/
	| 	<OR> <AFTER>/*@bgen(jjtree) TPDuring_Or_After_Period_Node */
                             {
                               SimpleNode jjtn002 = new SimpleNode(JJTTPDURING_OR_AFTER_PERIOD_NODE);
                               boolean jjtc002 = true;
                               jjtree.openNodeScope(jjtn002);
                               jjtreeOpenNodeScope(jjtn002);
                             }
                             try {
/*@egen*/ Period()/*@bgen(jjtree)*/
                             } catch (Throwable jjte002) {
                               if (jjtc002) {
                                 jjtree.clearNodeScope(jjtn002);
                                 jjtc002 = false;
                               } else {
                                 jjtree.popNode();
                               }
                               if (jjte002 instanceof RuntimeException) {
                                 throw (RuntimeException)jjte002;
                               }
                               if (jjte002 instanceof ParseException) {
                                 throw (ParseException)jjte002;
                               }
                               throw (Error)jjte002;
                             } finally {
                               if (jjtc002) {
                                 jjtree.closeNodeScope(jjtn002, true);
                                 jjtreeCloseNodeScope(jjtn002);
                               }
                             }
/*@egen*/
}

/*
 * <date-time expression ::= <date-time> | <period>
 */
void DateTimeExpression()     :
{}
{
		LOOKAHEAD(2) Period() 	
	| 	DateTime()						
}

/*
 *<period> ::= 
 *	  <date-time> "/" <date-time>
 * 	| <date-time> "/" <duration>
 * 	| <duration> "/" <date-time>
 */
void Period()      :
{}
{
		LOOKAHEAD(2)
		DateTime() <SLASH> PeriodTail() 	
	|	Duration() <SLASH>/*@bgen(jjtree) Period_With_Duration_Date_Node */
                                   {
                                     SimpleNode jjtn001 = new SimpleNode(JJTPERIOD_WITH_DURATION_DATE_NODE);
                                     boolean jjtc001 = true;
                                     jjtree.openNodeScope(jjtn001);
                                     jjtreeOpenNodeScope(jjtn001);
                                   }
                                   try {
/*@egen*/ DateTime()/*@bgen(jjtree)*/
                                   } catch (Throwable jjte001) {
                                     if (jjtc001) {
                                       jjtree.clearNodeScope(jjtn001);
                                       jjtc001 = false;
                                     } else {
                                       jjtree.popNode();
                                     }
                                     if (jjte001 instanceof RuntimeException) {
                                       throw (RuntimeException)jjte001;
                                     }
                                     if (jjte001 instanceof ParseException) {
                                       throw (ParseException)jjte001;
                                     }
                                     throw (Error)jjte001;
                                   } finally {
                                     if (jjtc001) {
                                       jjtree.closeNodeScope(jjtn001, true);
                                       jjtreeCloseNodeScope(jjtn001);
                                     }
                                   }
/*@egen*/
}

void PeriodTail()     :
{}
{/*@bgen(jjtree) Period_With_Date_Duration_Node */
                {
                  SimpleNode jjtn001 = new SimpleNode(JJTPERIOD_WITH_DATE_DURATION_NODE);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                  jjtreeOpenNodeScope(jjtn001);
                }
                try {
/*@egen*/
		Duration()/*@bgen(jjtree)*/
                } catch (Throwable jjte001) {
                  if (jjtc001) {
                    jjtree.clearNodeScope(jjtn001);
                    jjtc001 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte001 instanceof RuntimeException) {
                    throw (RuntimeException)jjte001;
                  }
                  if (jjte001 instanceof ParseException) {
                    throw (ParseException)jjte001;
                  }
                  throw (Error)jjte001;
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001, true);
                    jjtreeCloseNodeScope(jjtn001);
                  }
                }
/*@egen*/
	|/*@bgen(jjtree) Period_Between_Dates_Node */
                {
                  SimpleNode jjtn002 = new SimpleNode(JJTPERIOD_BETWEEN_DATES_NODE);
                  boolean jjtc002 = true;
                  jjtree.openNodeScope(jjtn002);
                  jjtreeOpenNodeScope(jjtn002);
                }
                try {
/*@egen*/	DateTime()/*@bgen(jjtree)*/
                } catch (Throwable jjte002) {
                  if (jjtc002) {
                    jjtree.clearNodeScope(jjtn002);
                    jjtc002 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte002 instanceof RuntimeException) {
                    throw (RuntimeException)jjte002;
                  }
                  if (jjte002 instanceof ParseException) {
                    throw (ParseException)jjte002;
                  }
                  throw (Error)jjte002;
                } finally {
                  if (jjtc002) {
                    jjtree.closeNodeScope(jjtn002, true);
                    jjtreeCloseNodeScope(jjtn002);
                  }
                }
/*@egen*/	
}

void DateTime()              : 
{/*@bgen(jjtree) DateTime_Node */
  SimpleNode jjtn000 = new SimpleNode(JJTDATETIME_NODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) DateTime_Node */
        try {
/*@egen*/
	<DATE_TIME>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/ 
}

/*
 * <duration> ::= "P" <dur-date> | <dur-time>
 * <dur-date> ::= <dur-day> | <dur-month> | <dur-year> [<dur-time>]
 * <dur-day> ::= <digit>... "D"
 * <dur-month> ::= <digit>... "M" [<dur-day>]
 * <dur-year> ::= <digit>... "Y" [<dur-month>]
 */
void Duration()     :
{}
{/*@bgen(jjtree) Duration_Date_Node */
                {
                  SimpleNode jjtn001 = new SimpleNode(JJTDURATION_DATE_NODE);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                  jjtreeOpenNodeScope(jjtn001);
                }
                try {
/*@egen*/
 		<DURATION>/*@bgen(jjtree)*/
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001, true);
                    jjtreeCloseNodeScope(jjtn001);
                  }
                }
/*@egen*/
}

/* ---------------------------------------- *
 *  End <temporal predicate>
 * ---------------------------------------- */

/* ---------------------------------------- *
 *  <existence predicate>
 * ---------------------------------------- */
/*
 * <existence_predicate> ::= <attribute_name> EXISTS
 * | <attribute_name> DOES-NOT-EXIST
 */
void ExistencePredicate()      :
{}
{/*@bgen(jjtree) Existence_Predicate_Exists_Node */
                {
                  SimpleNode jjtn001 = new SimpleNode(JJTEXISTENCE_PREDICATE_EXISTS_NODE);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                  jjtreeOpenNodeScope(jjtn001);
                }
                try {
/*@egen*/
		<EXISTS>/*@bgen(jjtree)*/
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001, true);
                    jjtreeCloseNodeScope(jjtn001);
                  }
                }
/*@egen*/
	|/*@bgen(jjtree) Existence_Predicate_DoesNotExist_Node */
                {
                  SimpleNode jjtn002 = new SimpleNode(JJTEXISTENCE_PREDICATE_DOESNOTEXIST_NODE);
                  boolean jjtc002 = true;
                  jjtree.openNodeScope(jjtn002);
                  jjtreeOpenNodeScope(jjtn002);
                }
                try {
/*@egen*/	<DOES_NOT_EXIST>/*@bgen(jjtree)*/
                } finally {
                  if (jjtc002) {
                    jjtree.closeNodeScope(jjtn002, true);
                    jjtreeCloseNodeScope(jjtn002);
                  }
                }
/*@egen*/
}
/* ---------------------------------------- *
 *  end <existence predicate>
 * ---------------------------------------- */

void TextPredicate()      :
{}
{
  	 	LOOKAHEAD(2)  <NOT> <LIKE>/*@bgen(jjtree) Not_Like_Node */
                                           {
                                             SimpleNode jjtn001 = new SimpleNode(JJTNOT_LIKE_NODE);
                                             boolean jjtc001 = true;
                                             jjtree.openNodeScope(jjtn001);
                                             jjtreeOpenNodeScope(jjtn001);
                                           }
                                           try {
/*@egen*/ CharacterPattern()/*@bgen(jjtree)*/
                                           } catch (Throwable jjte001) {
                                             if (jjtc001) {
                                               jjtree.clearNodeScope(jjtn001);
                                               jjtc001 = false;
                                             } else {
                                               jjtree.popNode();
                                             }
                                             if (jjte001 instanceof RuntimeException) {
                                               throw (RuntimeException)jjte001;
                                             }
                                             if (jjte001 instanceof ParseException) {
                                               throw (ParseException)jjte001;
                                             }
                                             throw (Error)jjte001;
                                           } finally {
                                             if (jjtc001) {
                                               jjtree.closeNodeScope(jjtn001, true);
                                               jjtreeCloseNodeScope(jjtn001);
                                             }
                                           }
/*@egen*/
  	|	              <LIKE>/*@bgen(jjtree) Like_Node */
                                     {
                                       SimpleNode jjtn002 = new SimpleNode(JJTLIKE_NODE);
                                       boolean jjtc002 = true;
                                       jjtree.openNodeScope(jjtn002);
                                       jjtreeOpenNodeScope(jjtn002);
                                     }
                                     try {
/*@egen*/ CharacterPattern()/*@bgen(jjtree)*/
                                     } catch (Throwable jjte002) {
                                       if (jjtc002) {
                                         jjtree.clearNodeScope(jjtn002);
                                         jjtc002 = false;
                                       } else {
                                         jjtree.popNode();
                                       }
                                       if (jjte002 instanceof RuntimeException) {
                                         throw (RuntimeException)jjte002;
                                       }
                                       if (jjte002 instanceof ParseException) {
                                         throw (ParseException)jjte002;
                                       }
                                       throw (Error)jjte002;
                                     } finally {
                                       if (jjtc002) {
                                         jjtree.closeNodeScope(jjtn002, true);
                                         jjtreeCloseNodeScope(jjtn002);
                                       }
                                     }
/*@egen*/
}


void CharacterPattern()      :
{}
{
  	StringLiteral() 
}

/*
 * Cql Extension
 * 
 *	<beween predicate>::= ["NOT"] "BETWEEN" expression "AND" expression
 */
void BetweenPredicate()      :
{}
{
	LOOKAHEAD(2) <NOT> <BETWEEN> Expression() <AND>/*@bgen(jjtree) Not_Between_Node */
                                                        {
                                                          SimpleNode jjtn001 = new SimpleNode(JJTNOT_BETWEEN_NODE);
                                                          boolean jjtc001 = true;
                                                          jjtree.openNodeScope(jjtn001);
                                                          jjtreeOpenNodeScope(jjtn001);
                                                        }
                                                        try {
/*@egen*/ Expression()/*@bgen(jjtree)*/
                                                        } catch (Throwable jjte001) {
                                                          if (jjtc001) {
                                                            jjtree.clearNodeScope(jjtn001);
                                                            jjtc001 = false;
                                                          } else {
                                                            jjtree.popNode();
                                                          }
                                                          if (jjte001 instanceof RuntimeException) {
                                                            throw (RuntimeException)jjte001;
                                                          }
                                                          if (jjte001 instanceof ParseException) {
                                                            throw (ParseException)jjte001;
                                                          }
                                                          throw (Error)jjte001;
                                                        } finally {
                                                          if (jjtc001) {
                                                            jjtree.closeNodeScope(jjtn001, true);
                                                            jjtreeCloseNodeScope(jjtn001);
                                                          }
                                                        }
/*@egen*/
  	|			 <BETWEEN> Expression() <AND>/*@bgen(jjtree) Between_Node */
                                                              {
                                                                SimpleNode jjtn002 = new SimpleNode(JJTBETWEEN_NODE);
                                                                boolean jjtc002 = true;
                                                                jjtree.openNodeScope(jjtn002);
                                                                jjtreeOpenNodeScope(jjtn002);
                                                              }
                                                              try {
/*@egen*/ Expression()/*@bgen(jjtree)*/
                                                              } catch (Throwable jjte002) {
                                                                if (jjtc002) {
                                                                  jjtree.clearNodeScope(jjtn002);
                                                                  jjtc002 = false;
                                                                } else {
                                                                  jjtree.popNode();
                                                                }
                                                                if (jjte002 instanceof RuntimeException) {
                                                                  throw (RuntimeException)jjte002;
                                                                }
                                                                if (jjte002 instanceof ParseException) {
                                                                  throw (ParseException)jjte002;
                                                                }
                                                                throw (Error)jjte002;
                                                              } finally {
                                                                if (jjtc002) {
                                                                  jjtree.closeNodeScope(jjtn002, true);
                                                                  jjtreeCloseNodeScope(jjtn002);
                                                                }
                                                              }
/*@egen*/
}

/*
 * cql extension
 */
 void Expression()      :
{}
{
   BinaryExpression()
}

void BinaryExpression()      :
{}
{
  MultiplicativeExpression()
  (
    <PLUS>/*@bgen(jjtree) #AddNode( 2) */
           {
             SimpleNode jjtn001 = new SimpleNode(JJTADDNODE);
             boolean jjtc001 = true;
             jjtree.openNodeScope(jjtn001);
             jjtreeOpenNodeScope(jjtn001);
           }
           try {
/*@egen*/ MultiplicativeExpression()/*@bgen(jjtree)*/
           } catch (Throwable jjte001) {
             if (jjtc001) {
               jjtree.clearNodeScope(jjtn001);
               jjtc001 = false;
             } else {
               jjtree.popNode();
             }
             if (jjte001 instanceof RuntimeException) {
               throw (RuntimeException)jjte001;
             }
             if (jjte001 instanceof ParseException) {
               throw (ParseException)jjte001;
             }
             throw (Error)jjte001;
           } finally {
             if (jjtc001) {
               jjtree.closeNodeScope(jjtn001,  2);
               jjtreeCloseNodeScope(jjtn001);
             }
           }
/*@egen*/
   |
    <MINUS>/*@bgen(jjtree) #SubtractNode( 2) */
            {
              SimpleNode jjtn002 = new SimpleNode(JJTSUBTRACTNODE);
              boolean jjtc002 = true;
              jjtree.openNodeScope(jjtn002);
              jjtreeOpenNodeScope(jjtn002);
            }
            try {
/*@egen*/ MultiplicativeExpression()/*@bgen(jjtree)*/
            } catch (Throwable jjte002) {
              if (jjtc002) {
                jjtree.clearNodeScope(jjtn002);
                jjtc002 = false;
              } else {
                jjtree.popNode();
              }
              if (jjte002 instanceof RuntimeException) {
                throw (RuntimeException)jjte002;
              }
              if (jjte002 instanceof ParseException) {
                throw (ParseException)jjte002;
              }
              throw (Error)jjte002;
            } finally {
              if (jjtc002) {
                jjtree.closeNodeScope(jjtn002,  2);
                jjtreeCloseNodeScope(jjtn002);
              }
            }
/*@egen*/
  )*
}
 


void MultiplicativeExpression()       :
{}
{
  
  UnaryExpression()
  (
    <MULT>/*@bgen(jjtree) #MulNode( 2) */
           {
             SimpleNode jjtn001 = new SimpleNode(JJTMULNODE);
             boolean jjtc001 = true;
             jjtree.openNodeScope(jjtn001);
             jjtreeOpenNodeScope(jjtn001);
           }
           try {
/*@egen*/ UnaryExpression()/*@bgen(jjtree)*/
           } catch (Throwable jjte001) {
             if (jjtc001) {
               jjtree.clearNodeScope(jjtn001);
               jjtc001 = false;
             } else {
               jjtree.popNode();
             }
             if (jjte001 instanceof RuntimeException) {
               throw (RuntimeException)jjte001;
             }
             if (jjte001 instanceof ParseException) {
               throw (ParseException)jjte001;
             }
             throw (Error)jjte001;
           } finally {
             if (jjtc001) {
               jjtree.closeNodeScope(jjtn001,  2);
               jjtreeCloseNodeScope(jjtn001);
             }
           }
/*@egen*/
   |
    <SLASH>/*@bgen(jjtree) #DivNode( 2) */
            {
              SimpleNode jjtn002 = new SimpleNode(JJTDIVNODE);
              boolean jjtc002 = true;
              jjtree.openNodeScope(jjtn002);
              jjtreeOpenNodeScope(jjtn002);
            }
            try {
/*@egen*/ UnaryExpression()/*@bgen(jjtree)*/
            } catch (Throwable jjte002) {
              if (jjtc002) {
                jjtree.clearNodeScope(jjtn002);
                jjtc002 = false;
              } else {
                jjtree.popNode();
              }
              if (jjte002 instanceof RuntimeException) {
                throw (RuntimeException)jjte002;
              }
              if (jjte002 instanceof ParseException) {
                throw (ParseException)jjte002;
              }
              throw (Error)jjte002;
            } finally {
              if (jjtc002) {
                jjtree.closeNodeScope(jjtn002,  2);
                jjtreeCloseNodeScope(jjtn002);
              }
            }
/*@egen*/
  )*
}

void UnaryExpression()      :
{}
{
	  LOOKAHEAD(Function()) Function() 
	| LOOKAHEAD(Attribute()) Attribute() 
	| Literal()
	| <LP> Expression()<RP>
	| <LSP> Expression()<RSP>
}

void Evaluate()      :
{}
{
  	LOOKAHEAD(Function()) Function() 
  |	Attribute()
}

/*
 * <identifier> ::= <identifier part> [ { <colon> | <identifier part> }... ] 
 */
void Identifier()                 :
{/*@bgen(jjtree) Identifier_Node */
  SimpleNode jjtn000 = new SimpleNode(JJTIDENTIFIER_NODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Identifier_Node */
        try {
/*@egen*/		
	IdentifierPart() (  <COLON> | IdentifierPart() )*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/	
}
void IdentifierPart()                      :
 {/*@bgen(jjtree) Identifier_Part_Node */
  SimpleNode jjtn000 = new SimpleNode(JJTIDENTIFIER_PART_NODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
 {/*@bgen(jjtree) Identifier_Part_Node */
        try {
/*@egen*/
 	<IDENTIFIER>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/
 }
 
 
  
/*
 * <attribute name> ::= 
 *  	  <simple attribute name> 
 * 		| <compound attribute name>
 * 
 * <compound attribute name> ::= 
 * 		<identifier><period> [{<identifier><period>}*] <simple attribute name>
 *
 * <simple attribute name> ::= <identifier>
 */ 
void Attribute()      :
{}
{
	 	SimpleAttributeName() AttributeTail() 
}

/*
 * <simple attribute name> ::= <identifier>
 */
void SimpleAttributeName()                       :
{/*@bgen(jjtree) Simple_Attribute_Node */
  SimpleNode jjtn000 = new SimpleNode(JJTSIMPLE_ATTRIBUTE_NODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Simple_Attribute_Node */
        try {
/*@egen*/
	Identifier()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/	
}

void AttributeTail()                         :
{/*@bgen(jjtree) Compound_Attribute_Node */
  SimpleNode jjtn000 = new SimpleNode(JJTCOMPOUND_ATTRIBUTE_NODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Compound_Attribute_Node */
         try {
/*@egen*/
 	 (  <PERIOD> SimpleAttributeName() )*/*@bgen(jjtree)*/
         } catch (Throwable jjte000) {
           if (jjtc000) {
             jjtree.clearNodeScope(jjtn000);
             jjtc000 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte000 instanceof RuntimeException) {
             throw (RuntimeException)jjte000;
           }
           if (jjte000 instanceof ParseException) {
             throw (ParseException)jjte000;
           }
           throw (Error)jjte000;
         } finally {
           if (jjtc000) {
             jjtree.closeNodeScope(jjtn000, true);
             jjtreeCloseNodeScope(jjtn000);
           }
         }
/*@egen*/ 
}

/*
 * <literal> ::= 
 *			<signed numeric literal>
 * 		| 	<general literal>
 */
void Literal()       :
{}
{
		SignedNumericLiteral()
	| 	GeneralLiteral()	
}

void SignedNumericLiteral()       :
{}
{
  	IntegerLiteral() 
  | FloatingLiteral()
}
/*
 *<general literal> ::= 
 * 			<character string literal>
 * 		| 	<datetime literal>
 * 		| 	<boolean literal>
 * 		| 	<geography literal
 */   
void GeneralLiteral()      :
{}
{
  	StringLiteral()
  |	BooleanLiteral() 
//  | GeographyLiteral()  TODO
}

void IntegerLiteral()             :
{/*@bgen(jjtree) IntegerNode */
  SimpleNode jjtn000 = new SimpleNode(JJTINTEGERNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) IntegerNode */
  try {
/*@egen*/
  <INTEGER_LITERAL>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void FloatingLiteral()              :
{/*@bgen(jjtree) FloatingNode */
  SimpleNode jjtn000 = new SimpleNode(JJTFLOATINGNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FloatingNode */
  try {
/*@egen*/
  <FLOATING_LITERAL>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void BooleanLiteral()       :
{}
{/*@bgen(jjtree) TrueNode */
  {
    SimpleNode jjtn001 = new SimpleNode(JJTTRUENODE);
    boolean jjtc001 = true;
    jjtree.openNodeScope(jjtn001);
    jjtreeOpenNodeScope(jjtn001);
  }
  try {
/*@egen*/
  <TRUE>/*@bgen(jjtree)*/
  } finally {
    if (jjtc001) {
      jjtree.closeNodeScope(jjtn001, true);
      jjtreeCloseNodeScope(jjtn001);
    }
  }
/*@egen*/ |/*@bgen(jjtree) FalseNode */
  {
    SimpleNode jjtn002 = new SimpleNode(JJTFALSENODE);
    boolean jjtc002 = true;
    jjtree.openNodeScope(jjtn002);
    jjtreeOpenNodeScope(jjtn002);
  }
  try {
/*@egen*/
  <FALSE>/*@bgen(jjtree)*/
  } finally {
    if (jjtc002) {
      jjtree.closeNodeScope(jjtn002, true);
      jjtreeCloseNodeScope(jjtn002);
    }
  }
/*@egen*/
}

void StringLiteral()             :
{/*@bgen(jjtree) StringNode */
  SimpleNode jjtn000 = new SimpleNode(JJTSTRINGNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) StringNode */
    try {
/*@egen*/
    <STRING_LITERAL>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/ 
}

/* ---------------------------------------- *
 *  <function>
 * ---------------------------------------- */
/*
 * <function> ::= <function name> "("<function arg> [,<function arg>]*)
 */
void Function()               :
{/*@bgen(jjtree) Function_Node */
  SimpleNode jjtn000 = new SimpleNode(JJTFUNCTION_NODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Function_Node */
                try {
/*@egen*/
  		FunctionName() 
  			<LP>( FunctionArg() (<COMMA> FunctionArg() )* )? <RP>/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtreeCloseNodeScope(jjtn000);
                  }
                }
/*@egen*/

}

void FunctionName()                   :
{/*@bgen(jjtree) FunctionName_Node */
  SimpleNode jjtn000 = new SimpleNode(JJTFUNCTIONNAME_NODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FunctionName_Node */
    try {
/*@egen*/
    <IDENTIFIER>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

/*
 * <argument>  ::= 
 *      <literal>  
 *  |   <attribute name>                                            
 * 	|	<expression> (*extension: expression includes literal and attributes*) 
 */
void FunctionArg()                  :
{/*@bgen(jjtree) FunctionArg_Node */
  SimpleNode jjtn000 = new SimpleNode(JJTFUNCTIONARG_NODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) FunctionArg_Node */
                try {
/*@egen*/
		Expression()/*@bgen(jjtree)*/
                } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    throw (RuntimeException)jjte000;
                  }
                  if (jjte000 instanceof ParseException) {
                    throw (ParseException)jjte000;
                  }
                  throw (Error)jjte000;
                } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtreeCloseNodeScope(jjtn000);
                  }
                }
/*@egen*/
}
/* ---------------------------------------- *
 *  end <function>
 * ---------------------------------------- */

/*
 * <Point> := <x><space><y>
 */
void Point()      :
{}
{
  NumericLiteral() NumericLiteral()
}

/*
 * <LineString Text> := EMPTY
 * | <left paren><Point>{<comma><Point >} ... <right paren>
 */
void LineStringText()      :
{}
{
  (<LP> Point() ( <COMMA> Point() )* <RP>)?
}

void PointTaggedText()         :
{/*@bgen(jjtree) WKTNode */
  SimpleNode jjtn000 = new SimpleNode(JJTWKTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/} 
{/*@bgen(jjtree) WKTNode */
  try {
/*@egen*/
  jjtn000.token = <POINT> PointText()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}
/*
 * <Point Text> := EMPTY | <left paren> <Point> <right paren>
 */
void PointText()      :
{}
{
	(<LP> Point() <RP>)?
}

void LineStringTaggedText()         :
{/*@bgen(jjtree) WKTNode */
  SimpleNode jjtn000 = new SimpleNode(JJTWKTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) WKTNode */
  try {
/*@egen*/
  jjtn000.token = <LINESTRING> LineStringText()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/ 
}
/*
 * <Polygon Tagged Text> := POLYGON <Polygon Text>
 */
void PolygonTaggedText()         :
{/*@bgen(jjtree) WKTNode */
  SimpleNode jjtn000 = new SimpleNode(JJTWKTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) WKTNode */
  try {
/*@egen*/
  jjtn000.token = <POLYGON> PolygonText()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}


/*
 * <Polygon Text> := EMPTY
 *  	| <left paren><LineString Text>{<comma><LineString Text>}*<right paren>
 */
void PolygonText()     :
{}
{
	(<LP> LineStringText() (<COMMA> LineStringText())* <RP>)?
}

/*
 * <MultiPoint Tagged Text> ::= MULTIPOINT <Multipoint Text>
 */
void MultiPointTaggedText()         :
{/*@bgen(jjtree) WKTNode */
  SimpleNode jjtn000 = new SimpleNode(JJTWKTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) WKTNode */
  try {
/*@egen*/
  jjtn000.token = <MULTIPOINT> MultiPointText()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}
/*
 * <Multipoint Text> := EMPTY
 * 	| ( <Point Text > {, <Point Text > }* )
 */
void MultiPointText()      :
{}
{
 	(<LP> PointText() (<COMMA> PointText() )* <RP>)?
}

/*
 * <MultiLineString Tagged Text> := MULTILINESTRING <MultiLineString Text>
 */
void MultiLineStringTaggedText()         :
{/*@bgen(jjtree) WKTNode */
  SimpleNode jjtn000 = new SimpleNode(JJTWKTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) WKTNode */
  try {
/*@egen*/
  jjtn000.token = <MULTILINESTRING> MultiLineStringText()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}
/*
 * <MultiLineString Text> := 
 *		EMPTY
 * 		| ( <LineString Text > {, < LineString Text > }* )
 */
void MultiLineStringText()      :
{}
{
	( <LP> LineStringText() (<COMMA> LineStringText())* <RP> )?
}
/*
 * <MultiPolygon Tagged Text> :: =MULTIPOLYGON <MultiPolygon Text>
 */
void MultiPolygonTaggedText()         :
{/*@bgen(jjtree) WKTNode */
  SimpleNode jjtn000 = new SimpleNode(JJTWKTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) WKTNode */
  try {
/*@egen*/
  jjtn000.token = <MULTIPOLYGON> MultiPolygonText()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}
/*
 * <MultiPolygon Text> := EMPTY
 * 	| <left paren><Polygon Text>{<comma><Polygon Text>}* <right paren>
 */
void MultiPolygonText()      :
{}
{
	( <LP> PolygonText() ( <COMMA> PolygonText() )* <RP> )?
}

void GeometryCollectionTaggedText()         :
{/*@bgen(jjtree) WKTNode */
  SimpleNode jjtn000 = new SimpleNode(JJTWKTNODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) WKTNode */
  try {
/*@egen*/
  jjtn000.token = <GEOMETRYCOLLECTION> GeometryCollectionText()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

/*
 * <GeometryCollection Text> := EMPTY
 * | ( <Geometry Tagged Text> {, <Geometry Tagged Text> }* )
 */
 void GeometryCollectionText()      :
 {}
 {
 	( <LP> GeometryLiteral() ( <COMMA> GeometryLiteral() )* <RP>)?
 }
 
/*
 * <Envelope Tagged Text> ::= ENVELOPE <Envelope Text>
 */
 void EnvelopeTaggedText()                         :
 {/*@bgen(jjtree) EnvelopeTaggedText_Node */
  SimpleNode jjtn000 = new SimpleNode(JJTENVELOPETAGGEDTEXT_NODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
 {/*@bgen(jjtree) EnvelopeTaggedText_Node */
        try {
/*@egen*/
 	jjtn000.token = <ENVELOPE> EnvelopText()/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/
 }

/*
 * <Envelope Text> := EMPTY
 * | <left paren>
 *		<WestBoundLongitude><comma>
 *   	<EastBoundLongitude><comma>
 *   	<NorthBoundLatitude><comma>
 *   	<SouthBoundLatitude>
 *	<right paren>
 * <WestBoundLongitude> := numeric literal
 * <EastBoundLongitude> := numeric literal
 * <NorthBoundLatitude> := numeric literal
 * <SouthBoundLatitude> := numeric literal
 */
 void EnvelopText()      :
 {}
 {
 	( <LP> 
 		NumericLiteral() <COMMA>
 		NumericLiteral() <COMMA>
 		NumericLiteral() <COMMA>
 		NumericLiteral() 
 	 <RP> )?
 }
 
void NumericLiteral()      :
{}
{
	<FLOATING_LITERAL>|<INTEGER_LITERAL>
}
